public class Actor {
   public Actor();

   /**
    * Die Methode act wird 30-mal pro Sekunde aufgerufen. Wenn Sie sie in einer Unterklasse überschreiben, so wird Ihre Methode 30-mal
    * pro Sekunde aufgerufen.
    **/
   public void act();

   /**
    * Die Methode act wird 30-mal pro Sekunde aufgerufen. Wenn Sie sie in einer Unterklasse überschreiben, so wird Ihre Methode 30-mal
    * pro Sekunde aufgerufen. DletaTime ist die seit dem letzten Aufruf verstrichene Zeit in ms.
    **/
   public void act(double deltaTime);

   /**
    * onKeyTyped wird jedes Mal dann aufgerufen, wenn eine Taste heruntergedrückt und anschließend losgelassen wird. Der Parameter key
    * enthält die gedrückte Taste. Im Fall von Sondertasten (Enter, Pfeiltasten...) wird eine der Konstanten Key.Enter, Key.ArrowUp,
    * ... übergeben.
    **/
   public void onKeyTyped(String key);

   public void onKeyUp(String key);

   public void onKeyDown(String key);

   public void destroy();

   /**
    * onKeyUp wird jedes Mal dann aufgerufen, wenn eine Taste losgelassen wird. Der Parameter key enthält die gedrückte Taste. Im Fall
    * von Sondertasten (Enter, Pfeiltasten...) wird eine der Konstanten Key.Enter, Key.ArrowUp, ... übergeben.
    **/
   public final boolean isKeyUp(String key);

   /**
    * onKeyDown wird jedes Mal dann aufgerufen, wenn eine Taste gedrückt wird. Der Parameter key enthält die gedrückte Taste. Im Fall
    * von Sondertasten (Enter, Pfeiltasten...) wird eine der Konstanten Key.Enter, Key.ArrowUp, ... übergeben.
    **/
   public final boolean isKeyDown(String key);

   /**
    * Gibt genau dann true zurück, wenn die act-Methode 30-mal pro Sekunden aufgerufen wird. Nutzen Sie die Methoden stopActing und
    * restartActing um dies zu deaktivieren bzw. zu aktivieren.
    **/
   public final boolean isActing();

   /**
    * Gibt genau dann true zurück, wenn das Objekt durch Aufruf der Methode destroy() zerstört worden ist.
    **/
   public final boolean isDestroyed();

   /**
    * Sorgt dafür, dass die act-Methode dieses Objekts zukünftig nicht mehr 30-mal pro Sekunde aufgerufen wird.
    **/
   public final void stopActing();

   /**
    * Sorgt dafür, dass die act-Methode dieses Objekts zukünftig wieder 30-mal pro Sekunde aufgerufen wird.
    **/
   public final void restartActing();

   /**
    * Gibt genau dann true zurück, wenn der Button buttonIndex des Gamepads GamepadIndex gedrückt ist.
    **/
   public final boolean isGamepadButtonDown(int gamepadIndex, int buttonIndex);

   /**
    * Gibt true zurück, falls das Gamepad mit dem übergebenen Index angeschlossen ist. VORSICHT: Das erste Gamepad hat Index 0.
    **/
   public final boolean isGamepadConnected(int gamepadIndex);

   /**
    * Gibt den Wert des Gamepad-Steuerknüppels mit Index axisIndex zurück.
    **/
   public final double getGamepadAxisValue(int gamepadIndex, int axisIndex);

}

/**
 * Ausrichtung
 **/
public enum Alignment {
   left, center, right, top, bottom;

   public static Alignment[] values();

   public static Alignment valueOf(String name);

}

public class AmbientLight3d {
   public AmbientLight3d();

   public AmbientLight3d(double intensity);

}

/**
 * Kreisbogenumriss (wahlweise gefüllt)
 **/
public class Arc {
   /**
    * Instanziert einen neuen Kreisbogen. (mx, my) ist der Mittelpunt, ri sein Innenradius, ra sein Außenradius. Der Kreisbogen wird
    * von startAngle bis endAngle (beides in Grad) gegen den Uhrzeigersinn gezogen.
    **/
   public Arc(double mx, double my, double innerRadius, double outerRadius, double startAngle, double endAngle);

   /**
    * Instanziert einen neuen Kreisbogen.
    **/
   public Arc();

   /**
    * Setzt den Innenradius des Kreisbogens.
    **/
   public final void setInnerRadius(double innerRadius);

   /**
    * Liefert den Innenradius des Kreisbogens.
    **/
   public final double getInnerRadiusX();

   /**
    * Setzt den Außenradius des Kreisbogens.
    **/
   public final void setOuterRadius(double outerRadius);

   /**
    * Liefert den Außenradius des Kreisbogens.
    **/
   public final double getOuterRadiusX();

   /**
    * Setzt den Startwinkel des Kreisbogens (in Grad).
    **/
   public final void setStartAngle(double startAngle);

   /**
    * Liefert den Startwinkel des Kreisbogens (in Grad).
    **/
   public final double getStartAngleX();

   /**
    * Setzt den Endwinkel des Kreisbogens (in Grad).
    **/
   public final void setEndAngle(double endAngle);

   /**
    * Liefert den Endwinkel des Kreisbogens (in Grad).
    **/
   public final double getEndAngleX();

   /**
    * Erstellt eine Kopie des arc-Objekts und git sie zurück.
    **/
   public final Arc copy();

   /**
    * Gibt genau dann true zurück, wenn die Figur den angegebenen Punkt enthält.
    **/
   public final boolean containsPoint(double x, double y);

   /**
    * Wandelt das Objekt in eine Zeichenkette um und liefert diese zurück.
    **/
   public String toString();

}

public class ArithmeticException {
   public ArithmeticException();

   public ArithmeticException(String message);

   public ArithmeticException(Throwable cause);

   public ArithmeticException(String message, Throwable cause);

   public String toString();

}

public class ArrayCamera3d {
   public ArrayCamera3d(PerspectiveCamera3d[] cameras);

}

/**
 * Die Klasse ArrayList ist eine Liste, deren Elemente in einem Array gespeichert sind. Wird das Array zu klein, kopiert die
 * ArrayList es automatisch in ein größeres Array.
 **/
public class ArrayList<E> {
   /**
    * Instanziert (d.h. erzeugt) eine neue, leere Liste.
    **/
   public ArrayList();

   /**
    * Gibt ein Iterator-Objekt zurück, mit dem über alle Elemente der Liste in der gespeicherten Reihenfolge iteriert werden kann.
    **/
   public Iterator<E> iterator();

   /**
    * Führt die angegebene Methode (Aktion) für jedes Element der ArrayList aus.
    * Tipp: Die Aktion kann in Lambda-Schreibweise angegeben werden, z.B. foreach((element) -> {...})
    **/
   public void forEach(Consumer<?> action);

   /**
    * Wandelt die Collection in ein Array um und gibt dieses zurück.
    **/
   public Object[] toArray();

   /**
    * Wandelt die Collection in ein Array um und gibt dieses zurück. Als Parameter muss ein Muster-Array übergeben werden, das den Typ
    * des zurückgegebenen Arrays bestimmt.
    **/
   public <T> T[] toArray(T[] a);

   /**
    * Fügt das übergebene Element ans Ende der Liste an.
    **/
   public boolean add(E e);

   /**
    * Fügt alle Elemente der übergebenen Collection ans Ende der Liste an.
    **/
   public boolean addAll(Collection<?> c);

   /**
    * Entleert die Liste. Die Liste ist nach Aufruf dieser Methode leer. Die Elemente der Liste werden dadurch nicht beeinträchtigt.
    **/
   public void clear();

   /**
    * Gibt genau dann true zurück, wenn die Liste das angegebene Element enthält.
    **/
   public boolean contains(E Element);

   /**
    * Gibt genau dann true zurück, wenn die Liste alle Elemente der übergebenen Collection enthält.
    **/
   public boolean containsAll(Collection<?> c);

   /**
    * Gibt genau dann true zurück, wenn die Liste leer ist, d.h. keine Elemente enthält.
    **/
   public boolean isEmpty();

   /**
    * Falls die Liste das übergebene Element enthält, entnimmt diese Methode der Liste das erste solche Element. Die Methode gibt
    * genau dann true zurück, wenn die Liste das Element enthalten hat.
    **/
   public boolean remove(E element);

   /**
    * Entnimnt der Liste alle Vorkommen aller Elemente der übergebenen Collection.
    **/
   public boolean removeAll(Collection<?> c);

   /**
    * Gibt die Anzahl der in der Liste enthaltenen Elemente zurück. Ist ein Element mehrfach enthalten, so wird es dabei mehrfach
    * gezählt.
    **/
   public int size();

   /**
    * Gibt einen Stream zurück, der diese Collection als Quelle hat.
    **/
   public Stream<E> stream();

   /**
    * Fügt das angegebene Element an der angegebenen Position in die Liste ein. Alle nachfolgendne Elemente werden um eine Position
    * nach hinten verschoben.
    **/
   public boolean add(int index, E element);

   /**
    * Fügt alle Elemente der übergebenen Collection an der angegebenen Position in die Liste ein. Alle nachfolgendne Elemente werden
    * entsprechend nach hinten verschoben.
    **/
   public boolean addAll(int index, Collection<?> c);

   /**
    * Gibt das Element an der angegebenen Position zurück.
    *  Das erste Element der Liste hat Position 0.
    **/
   public E get(int index);

   /**
    * Gibt den Index des angegebenen Elements in der Liste zurück. Falls das Element nicht in der Liste enthalten ist, wird -1
    * zurückgegeben.
    * Tipp: Das erste Element der Liste hat Index 0.
    **/
   public int indexOf(E Element);

   /**
    * Entfernt das Element mit dem angegebenen Index aus der Liste.
    * Tipp: Das erste Element der Liste hat Index 0.
    **/
   public E remove(int index);

   /**
    * Setzt das übergebene Element an der angegebenen Position in die Liste anstatt des bisher dort vorhandenen.
    **/
   public E set(int index, E Element);

   /**
    * Sortiert die Liste anhand des übergebenen Comparator-Objekts.
    **/
   public void sort(Comparator<?> comparator);

   /**
    * Wandelt das Objekt in eine Zeichenkette um und liefert diese zurück.
    **/
   public String toString();

}

public class Assertions {
   public static void assertCodeReached(String message);

   public static void assertTrue(boolean condition, String message);

   public static void assertFalse(boolean condition, String message);

   public static void assertEquals(byte expected, byte actual, String message);

   public static void assertEquals(int expected, int actual, String message);

   public static void assertEquals(long expected, long actual, String message);

   public static void assertEquals(double expected, double actual, String message);

   public static void assertEquals(float expected, float actual, String message);

   public static void assertEquals(char expected, char actual, String message);

   public static void assertEquals(String expected, String actual, String message);

   public static void assertEquals(Object expected, Object actual, String message);

   public static void fail(String message);

}

/**
 * Ein Material, das keine Lichtquelle berücksichtigt, sondern jede Fläche einfach nur mit ihrer Farbe füllt. Geeignet vor allem
 * für Wireframe-Darstellung. Im Vergleich zu den anderen Materialien bietet es die beste Performance.
 **/
public class BasicMaterial3d {
   /**
    * Legt fest, ob das Objekt ungefüllt (nur als Gitter) gezeichnet werden soll.
    **/
   public boolean wireframe;
   /**
    * Erzeugt ein BasicMaterial-Objekt. Wireframe == true bewirkt, dass nur die Kanten gezeichnet werden.
    **/
   public BasicMaterial3d(int color);

   /**
    * Erzeugt ein BasicMaterial-Objekt. Wireframe == true bewirkt, dass nur die Kanten gezeichnet werden.
    **/
   public BasicMaterial3d(int color, boolean wireframe);

   /**
    * Erzeugt ein BasicMaterial-Objekt. Wireframe == true bewirkt, dass nur die Kanten gezeichnet werden.
    **/
   public BasicMaterial3d(String color, boolean wireframe);

   /**
    * Erzeugt ein BasicMaterial-Objekt. Wireframe == true bewirkt, dass nur die Kanten gezeichnet werden.
    **/
   public BasicMaterial3d(Color color, boolean wireframe);

   /**
    * Erzeugt ein BasicMaterial-Objekt mit einer Textur, z.B. new BasicMaterial(Texture.earth2k).
    **/
   public BasicMaterial3d(Texture texture);

   /**
    * Erzeugt ein BasicMaterial-Objekt mit einer Textur, z.B. new BasicMaterial(SpriteLibrary.plattforms, 20).
    **/
   public BasicMaterial3d(SpriteLibrary spriteLibrary, int imageIndex);

   /**
    * Legt fest, ob das Objekt ungefüllt (nur als Gitter) gezeichnet werden soll.
    **/
   public boolean isWireframe();

   /**
    * Legt fest, ob das Objekt ungefüllt (nur als Gitter) gezeichnet werden soll.
    **/
   public void setWireframe(boolean value);

}

public interface BiConsumer<T, U> {
   public void accept(T t, U u);

}

/**
 * Repräsentiert eine ganze Zahl mit 'beliebig' vielen Stellen.
 **/
public class BigInteger {
   /**
    * Instanziert ein neues BigInteger-Objekt.
    **/
   public BigInteger(long val);

   /**
    * Instanziert ein neues BigInteger-Objekt.
    **/
   public BigInteger(String val);

   /**
    * Addiert das übergebene BigInteger-Objekt zum aktuellen BigInteger-Objekt und gibt ein neues BigInteger-Objekt zurück, dessen
    * Wert die errechnete Summe ist. Die Methode add ändert nicht das aktuelle BigInteger-Objekt!
    **/
   public final BigInteger add(BigInteger otherNumber);

   /**
    * Subtrahiert das übergebene BigInteger-Objekt vom aktuellen BigInteger-Objekt und gibt ein neues BigInteger-Objekt zurück, dessen
    * Wert die errechnete Differenz ist. Die Methode add ändert nicht das aktuelle BigInteger-Objekt!
    **/
   public final BigInteger subtract(BigInteger otherNumber);

   /**
    * Dividiert das BigInteger-Objekt durch das übergebene undd gibt ein neues BigInteger-Objekt zurück, dessen Wert der errechnete
    * Quotient ist. Die Methode add ändert nicht das aktuelle BigInteger-Objekt!
    **/
   public final BigInteger divide(BigInteger otherNumber);

   /**
    * Multipliziert das aktuelle Objekt mit dem übergebenen BigInteger-Objekt und gibt ein neues BigInteger-Objekt zurück, dessen Wert
    * das Produkt der beiden Zahlen ist. Die Methode multiply ändert nicht das aktuelle BigInteger-Objekt!
    **/
   public final BigInteger multiply(BigInteger otherNumber);

   /**
    * Dividiert das BigInteger-Objekt durch das übergebene undd gibt ein neues BigInteger-Objekt zurück, dessen Wert der Rest der
    * Division ist. Die Methode add ändert nicht das aktuelle BigInteger-Objekt!
    **/
   public final BigInteger remainder(BigInteger otherNumber);

   /**
    * Dividiert das BigInteger-Objekt durch das übergebene undd gibt ein neues BigInteger-Objekt zurück, dessen Wert der Rest der
    * Division ist. Die Methode add ändert nicht das aktuelle BigInteger-Objekt!
    **/
   public final BigInteger modPow(BigInteger exponent, BigInteger m);

   /**
    * Gibt das BigInteger-Objekt als Zeichenkette (dezimal!) zurück.
    **/
   public final String toString();

   /**
    * Gibt das BigInteger-Objekt mod (2^53) als int-Wert zurück.
    **/
   public final int intValue();

}

/**
 * Rechteckige Bitmap in der Grafikausgabe
 **/
public class Bitmap {
   /**
    * Instanziert eine neue Bitmap. pointsX bzw. pointsY bezeichnet Anzahl der Bildpunkte in x bzw. y-Richtung, (left, top) sind die
    * Koordinaten der linken oberen Ecke.
    **/
   public Bitmap(int pointsX, int pointsY, double left, double top, double displayWidth, double displayHeight);

   /**
    * Setzt die Farbe des angegebenen Bildpunkts auf der Bitmap.
    **/
   public final void setColor(int x, int y, int color, double alpha);

   /**
    * Setzt die Farbe des angegebenen Bildpunkts auf der Bitmap.
    **/
   public final void setColor(int x, int y, String color, double alpha);

   /**
    * Setzt die Farbe des angegebenen Bildpunkts auf der Bitmap.
    **/
   public final void setColor(int x, int y, int color);

   /**
    * Setzt die Farbe des angegebenen Bildpunkts auf der Bitmap.
    **/
   public final void setColor(int x, int y, String color);

   /**
    * Gibt die Farbe des angegebenen Punktes als Color-Objekt zurück.
    **/
   public final Color getColor(int x, int y);

   /**
    * Gibt die Farbe des angegebenen Punktes als Color-Objekt zurück.
    **/
   public final int getColorAsInt(int x, int y);

   /**
    * Gibt genau dann true zurück, wenn die Farbe am angegebenen Punkt (x,y) mit der übergebenen Farbe übereinstimmt.
    **/
   public final boolean isColor(int x, int y, String colorAsRGBString);

   /**
    * Gibt genau dann true zurück, wenn die Farbe am angegebenen Punkt (x,y) mit der übergebenen Farbe übereinstimmt.
    **/
   public final boolean isColor(int x, int y, int color);

   /**
    * Wandelt die Weltkoordinaten (x,y) in Koordinaten innerhalb der Bitmap um.
    **/
   public final Position screenCoordinatesToBitmapCoordinates(double x, double y);

   /**
    * Füllt die ganze Bitmap mit der angegebenen Farbe.
    **/
   public final void fillAll(int color, double alpha);

   /**
    * Füllt die ganze Bitmap mit der angegebenen Farbe.
    **/
   public final void fillAll(String colorAsRGBString, double alpha);

   /**
    * Erzeugt eine Kopie dieser Bitmap.
    **/
   public final Bitmap copy();

   /**
    * Wandelt das Objekt in eine Zeichenkette um und liefert diese zurück.
    **/
   public String toString();

}

public class Boolean {
   public static final boolean FALSE;
   public static final boolean TRUE;
   public final boolean booleanValue();

   public int compareTo(Boolean otherBoolean);

   public static boolean getBoolean(String name);

   public static boolean parseBoolean(String name);

}

/**
 * Würfel (3D)
 **/
public class Box3d {
   /**
    * Erzeugt einen neuen Würfel mit der Kantenlänge 1. (x, y, z) ist der Ort seines Mittelpunkts (genauer: seines
    * Diagonalenschnittpunkts).
    **/
   public Box3d(double width, double height, double depth, int widthSegments, int heightSegments, int depthSegments);

   /**
    * Erzeugt einen neuen Würfel mit der Kantenlänge 1. (x, y, z) ist der Ort seines Mittelpunkts (genauer: seines
    * Diagonalenschnittpunkts).
    **/
   public Box3d(double width, double height, double depth);

   /**
    * Erzeugt einen neuen Würfel mit der Kantenlänge 1. Sein Mittelpunkt befindet sich bei (0, 0, 0)
    **/
   public Box3d();

   public void setCubemapTexture(SpriteLibrary spriteLibrary, int imageIndex);

   public void setSingleTextureForAllSides(SpriteLibrary spriteLibrary, int imageIndex);

   public void setTextures(SpriteLibrary spriteLibrary, int[] imageIndices);

}

/**
 * Button, der innerhalb der Grafikausgabe dargestellt werden kann
 **/
public class Button {
   /**
    * Instanziert ein neues Button-Objekt. (x, y) sind die Koordinaten der linken oberen Ecke, fontsize die Höhe des Textes in Pixeln.
    **/
   public Button(double x, double y, double fontsize, String text);

   /**
    * Instanziert ein neues Button-Objekt. (x, y) sind die Koordinaten der linken oberen Ecke, fontsize die Höhe des Textes in Pixeln.
    **/
   public Button(double x, double y, double fontsize, String text, String fontFamily);

   /**
    * Erstellt eine Kopie des Button-Objekts und git sie zurück.
    **/
   public Button copy();

   /**
    * Gibt genau dann true zurück, wenn der Button gerade heruntergedrückt ist.
    **/
   public boolean isDown();

}

public class Camera3d {
   public Camera3d();

   public void move(double x, double y, double z);

   public final void move(Vector3 v);

   public void moveTo(double x, double y, double z);

   public final void moveTo(Vector3 p);

   public void lookAt(double xTarget, double yTarget, double zTarget, Vector3 up, boolean keepTarget);

   public void lookAt(Object3d target, Vector3 up, boolean keepTarget);

   public void rotateX(double angleDeg);

   public void rotateY(double angleDeg);

   public void rotateZ(double angleDeg);

   public final void scaleX(double angleDeg);

   public final void scaleY(double angleDeg);

   public final void scaleZ(double angleDeg);

   public final void scale(Vector3 v);

   public final void scale(double d);

   public final void applyMatrix4(Matrix4 matrix);

   public void destroy();

}

public class Character {
   public Character(char value);

   public final char charValue();

   public int compareTo(Character otherCharacter);

   public static Character valueOf(char c);

   public static boolean isLetter(char c);

   public static boolean isLetterOrDigit(char c);

   public static boolean isDigit(char c);

   public static boolean isLowerCase(char c);

   public static boolean isUpperCase(char c);

   public static char toUpperCase(char c);

   public static char toLowerCase(char c);

   public String toString();

}

/**
 * Checkbox, die innerhalb der Grafikausgabe dargestellt werden kann
 **/
public class Checkbox {
   /**
    * Instanziert ein neues CheckBox-Objekt. (x, y) sind die Koordinaten der linken oberen Ecke, fontsize die Höhe des Textes in
    * Pixeln.
    **/
   public Checkbox(double x, double y, double width, double fontsize, String text);

   /**
    * Instanziert ein neues CheckBox-Objekt. (x, y) sind die Koordinaten der linken oberen Ecke, fontsize die Höhe des Textes in
    * Pixeln.
    **/
   public Checkbox(double x, double y, double width, double fontsize, String text, String fontFamily);

   /**
    * Instanziert ein neues CheckBox-Objekt. (x, y) sind die Koordinaten der linken oberen Ecke, fontsize die Höhe des Textes in
    * Pixeln.
    **/
   public Checkbox(double x, double y, double width, double fontsize, String text, boolean checked);

   /**
    * Erstellt eine Kopie der CheckBox.
    **/
   public Checkbox copy();

   /**
    * Setzt die Farbe des Kreuzchens. Die Farbe wird als int-Wert gegeben, wobei farbe == 256*256*rot + 256*grün + blau
    **/
   public void setCrossColor(int color);

   /**
    * Setzt den Zustand der Checkbox: angekreuzt bzw. nicht angekreuzt
    **/
   public void setChecked(boolean checked);

   /**
    * Gibt genau dann true zurück, falls die Checkbox angekreuzt ist.
    **/
   public boolean isChecked();

}

/**
 * Kreis
 **/
public class Circle {
   /**
    * Instanziert einen neuen Kreis mit Mittelpunkt (50, 50) und Radius 50.
    **/
   public Circle();

   /**
    * Instanziert einen neuen Kreis. (mx, my) ist der Mittelpunt, r sein Radius.
    **/
   public Circle(double mx, double my, double r);

   /**
    * Setzt den Radius des Kreises.
    **/
   public final void setRadius(double radius);

   /**
    * Gibt den Radius des Kreises zurück.
    **/
   public final double getRadius();

   /**
    * Erstellt eine Kopie des Circle-Objekts und git sie zurück.
    **/
   public final Circle copy();

   /**
    * Gibt genau dann true zurück, wenn die Figur den angegebenen Punkt enthält.
    **/
   public final boolean containsPoint(double x, double y);

   /**
    * Wandelt das Objekt in eine Zeichenkette um und liefert diese zurück.
    **/
   public String toString();

}

public class Circle3d {
   public Circle3d(double radius, int segments, double thetaStart, double thetaLength);

   public Circle3d(double radius, int segments);

   public Circle3d(double radius);

   public Circle3d();

}

/**
 * Jeder Klasse/jedem enum ist ein Objekt der Klasse Class zugeordnet.
 **/
public class Class<T> {
   /**
    * Gibt den Bezeichner der Klasse zurück.
    **/
   public String getName();

}

public class ClassCastException {
}

public interface Collection<E> {
   /**
    * Fügt das übergebene Element ans Ende der Liste an.
    **/
   public boolean add(E e);

   /**
    * Fügt alle Elemente der übergebenen Collection ans Ende der Liste an.
    **/
   public boolean addAll(Collection<?> c);

   /**
    * Entleert die Liste. Die Liste ist nach Aufruf dieser Methode leer. Die Elemente der Liste werden dadurch nicht beeinträchtigt.
    **/
   public void clear();

   /**
    * Gibt genau dann true zurück, wenn die Liste das angegebene Element enthält.
    **/
   public boolean contains(E element);

   /**
    * Gibt genau dann true zurück, wenn die Liste alle Elemente der übergebenen Collection enthält.
    **/
   public boolean containsAll(Collection<?> c);

   /**
    * Gibt genau dann true zurück, wenn die Liste leer ist, d.h. keine Elemente enthält.
    **/
   public boolean isEmpty();

   /**
    * Falls die Liste das übergebene Element enthält, entnimmt diese Methode der Liste das erste solche Element. Die Methode gibt
    * genau dann true zurück, wenn die Liste das Element enthalten hat.
    **/
   public boolean remove(E element);

   /**
    * Entnimnt der Liste alle Vorkommen aller Elemente der übergebenen Collection.
    **/
   public boolean removeAll(Collection<?> c);

   /**
    * Gibt die Anzahl der in der Liste enthaltenen Elemente zurück. Ist ein Element mehrfach enthalten, so wird es dabei mehrfach
    * gezählt.
    **/
   public int size();

   /**
    * Wandelt die Collection in ein Array um und gibt dieses zurück.
    **/
   public Object[] toArray();

   /**
    * Wandelt die Collection in ein Array um und gibt dieses zurück. Als Parameter muss ein Muster-Array übergeben werden, das den Typ
    * des zurückgegebenen Arrays bestimmt.
    **/
   public <T> T[] toArray(T[] a);

   /**
    * Gibt einen Stream zurück, der diese Collection als Quelle hat.
    **/
   public Stream<E> stream();

}

/**
 * Diese Klasse besteht aus Methoden, die auf Collections operieren oder Collections zurückgeben.
 **/
public class Collections {
   /**
    * Vertauscht die Elemente der Liste in zufälliger Weise.
    **/
   public static void shuffle(List<?> list);

   /**
    * Sortiert eine Liste von Elementen, die das Interface Comparable implementieren.
    **/
   public static <T extends Comparable> void sort(List<T> list);

   /**
    * Sortiert eine Liste von Elementen, die das Interface Comparable implementieren.
    **/
   public static <T> void sort(List<T> list, Comparator<?> comparator);

}

/**
 * Speichert die Referenzen auf zwei Figuren, die gerade kollidiert sind. Diese Klasse von den Kollisionsmethden der Klasse Group
 * benutzt.
 **/
public class CollisionPair<U extends Shape, V extends Shape> {
   /**
    * Die erste der beiden kollidierenden Figuren. Sie gehört zu group1 des Methodenaufrufs group1.getCollisionPairs(group2).
    **/
   public U shapeA;
   /**
    * Die zweite der beiden kollidierenden Figuren. Sie gehört zu group2 des Methodenaufrufs group1.getCollisionPairs(group2).
    **/
   public V shapeB;
   /**
    * Erzeugt ein paar zweier Shape-objekte.
    **/
   public CollisionPair(U ShapeA, V shapeB);

}

public class Color {
   public int red;
   public int green;
   public int blue;
   public double alpha;
   public static final Color aliceblue;
   public static final Color antiquewhite;
   public static final Color aqua;
   public static final Color aquamarine;
   public static final Color azure;
   public static final Color beige;
   public static final Color bisque;
   public static final Color black;
   public static final Color blanchedAlmond;
   public static final Color blue;
   public static final Color blueviolet;
   public static final Color brown;
   public static final Color burlywood;
   public static final Color cadetblue;
   public static final Color chartreuse;
   public static final Color chocolate;
   public static final Color coral;
   public static final Color cornflowerblue;
   public static final Color cornsilk;
   public static final Color crimson;
   public static final Color cyan;
   public static final Color darkblue;
   public static final Color darkcyan;
   public static final Color darkgoldenrod;
   public static final Color darkgray;
   public static final Color darkgrey;
   public static final Color darkgreen;
   public static final Color darkkhaki;
   public static final Color darkmagenta;
   public static final Color darkolivegreen;
   public static final Color darkorange;
   public static final Color darkorchid;
   public static final Color darkred;
   public static final Color darksalmon;
   public static final Color darkseagreen;
   public static final Color darkslateblue;
   public static final Color darkslategray;
   public static final Color darkslategrey;
   public static final Color darkturquoise;
   public static final Color darkviolet;
   public static final Color deeppink;
   public static final Color deepskyblue;
   public static final Color dimgray;
   public static final Color dimgrey;
   public static final Color dodgerblue;
   public static final Color firebrick;
   public static final Color floralwhite;
   public static final Color forestgreen;
   public static final Color fuchsia;
   public static final Color gainsboro;
   public static final Color ghostwhite;
   public static final Color gold;
   public static final Color goldenrod;
   public static final Color gray;
   public static final Color grau;
   public static final Color green;
   public static final Color greenyellow;
   public static final Color honeydew;
   public static final Color hotpink;
   public static final Color indianred;
   public static final Color indigo;
   public static final Color ivory;
   public static final Color khaki;
   public static final Color lavender;
   public static final Color lavenderblush;
   public static final Color lawngreen;
   public static final Color lemonchiffon;
   public static final Color lightblue;
   public static final Color lightcoral;
   public static final Color lightcyan;
   public static final Color lightgoldenrodyellow;
   public static final Color lightgray;
   public static final Color lightgrey;
   public static final Color lightgreen;
   public static final Color lightpink;
   public static final Color lightsalmon;
   public static final Color lightseagreen;
   public static final Color lightskyblue;
   public static final Color lightslategray;
   public static final Color lightslategrey;
   public static final Color lightsteelblue;
   public static final Color lightyellow;
   public static final Color lime;
   public static final Color limegreen;
   public static final Color linen;
   public static final Color magenta;
   public static final Color maroon;
   public static final Color mediumaquamarine;
   public static final Color mediumblue;
   public static final Color mediumorchid;
   public static final Color mediumpurple;
   public static final Color mediumseagreen;
   public static final Color mediumslateblue;
   public static final Color mediumspringgreen;
   public static final Color mediumturquoise;
   public static final Color mediumvioletred;
   public static final Color midnightblue;
   public static final Color mintcream;
   public static final Color mistyrose;
   public static final Color moccasin;
   public static final Color navajowhite;
   public static final Color navy;
   public static final Color oldLace;
   public static final Color olive;
   public static final Color olivedrab;
   public static final Color orange;
   public static final Color orangered;
   public static final Color orchid;
   public static final Color palegoldenrod;
   public static final Color palegreen;
   public static final Color paleturquoise;
   public static final Color palevioletred;
   public static final Color papayawhip;
   public static final Color peachpuff;
   public static final Color peru;
   public static final Color pink;
   public static final Color plum;
   public static final Color powderblue;
   public static final Color purple;
   public static final Color rebeccapurple;
   public static final Color red;
   public static final Color rosybrown;
   public static final Color royalblue;
   public static final Color saddlebrown;
   public static final Color salmon;
   public static final Color sandybrown;
   public static final Color sand;
   public static final Color seagreen;
   public static final Color seashell;
   public static final Color sienna;
   public static final Color silver;
   public static final Color skyblue;
   public static final Color slateblue;
   public static final Color slategray;
   public static final Color slategrey;
   public static final Color snow;
   public static final Color springgreen;
   public static final Color steelblue;
   public static final Color tan;
   public static final Color teal;
   public static final Color thistle;
   public static final Color tomato;
   public static final Color turquoise;
   public static final Color violet;
   public static final Color wheat;
   public static final Color white;
   public static final Color whitesmoke;
   public static final Color yellow;
   public static final Color yellowgreen;
   public static final Color aliceblue;
   public static final Color antiquewhite;
   public static final Color aqua;
   public static final Color aquamarine;
   public static final Color azure;
   public static final Color beige;
   public static final Color bisque;
   public static final Color black;
   public static final Color blanchedAlmond;
   public static final Color blue;
   public static final Color blueviolet;
   public static final Color brown;
   public static final Color burlywood;
   public static final Color cadetblue;
   public static final Color chartreuse;
   public static final Color chocolate;
   public static final Color coral;
   public static final Color cornflowerblue;
   public static final Color cornsilk;
   public static final Color crimson;
   public static final Color cyan;
   public static final Color darkblue;
   public static final Color darkcyan;
   public static final Color darkgoldenrod;
   public static final Color darkgray;
   public static final Color darkgrey;
   public static final Color darkgreen;
   public static final Color darkkhaki;
   public static final Color darkmagenta;
   public static final Color darkolivegreen;
   public static final Color darkorange;
   public static final Color darkorchid;
   public static final Color darkred;
   public static final Color darksalmon;
   public static final Color darkseagreen;
   public static final Color darkslateblue;
   public static final Color darkslategray;
   public static final Color darkslategrey;
   public static final Color darkturquoise;
   public static final Color darkviolet;
   public static final Color deeppink;
   public static final Color deepskyblue;
   public static final Color dimgray;
   public static final Color dimgrey;
   public static final Color dodgerblue;
   public static final Color firebrick;
   public static final Color floralwhite;
   public static final Color forestgreen;
   public static final Color fuchsia;
   public static final Color gainsboro;
   public static final Color ghostwhite;
   public static final Color gold;
   public static final Color goldenrod;
   public static final Color gray;
   public static final Color grau;
   public static final Color green;
   public static final Color greenyellow;
   public static final Color honeydew;
   public static final Color hotpink;
   public static final Color indianred;
   public static final Color indigo;
   public static final Color ivory;
   public static final Color khaki;
   public static final Color lavender;
   public static final Color lavenderblush;
   public static final Color lawngreen;
   public static final Color lemonchiffon;
   public static final Color lightblue;
   public static final Color lightcoral;
   public static final Color lightcyan;
   public static final Color lightgoldenrodyellow;
   public static final Color lightgray;
   public static final Color lightgrey;
   public static final Color lightgreen;
   public static final Color lightpink;
   public static final Color lightsalmon;
   public static final Color lightseagreen;
   public static final Color lightskyblue;
   public static final Color lightslategray;
   public static final Color lightslategrey;
   public static final Color lightsteelblue;
   public static final Color lightyellow;
   public static final Color lime;
   public static final Color limegreen;
   public static final Color linen;
   public static final Color magenta;
   public static final Color maroon;
   public static final Color mediumaquamarine;
   public static final Color mediumblue;
   public static final Color mediumorchid;
   public static final Color mediumpurple;
   public static final Color mediumseagreen;
   public static final Color mediumslateblue;
   public static final Color mediumspringgreen;
   public static final Color mediumturquoise;
   public static final Color mediumvioletred;
   public static final Color midnightblue;
   public static final Color mintcream;
   public static final Color mistyrose;
   public static final Color moccasin;
   public static final Color navajowhite;
   public static final Color navy;
   public static final Color oldLace;
   public static final Color olive;
   public static final Color olivedrab;
   public static final Color orange;
   public static final Color orangered;
   public static final Color orchid;
   public static final Color palegoldenrod;
   public static final Color palegreen;
   public static final Color paleturquoise;
   public static final Color palevioletred;
   public static final Color papayawhip;
   public static final Color peachpuff;
   public static final Color peru;
   public static final Color pink;
   public static final Color plum;
   public static final Color powderblue;
   public static final Color purple;
   public static final Color rebeccapurple;
   public static final Color red;
   public static final Color rosybrown;
   public static final Color royalblue;
   public static final Color saddlebrown;
   public static final Color salmon;
   public static final Color sandybrown;
   public static final Color sand;
   public static final Color seagreen;
   public static final Color seashell;
   public static final Color sienna;
   public static final Color silver;
   public static final Color skyblue;
   public static final Color slateblue;
   public static final Color slategray;
   public static final Color slategrey;
   public static final Color snow;
   public static final Color springgreen;
   public static final Color steelblue;
   public static final Color tan;
   public static final Color teal;
   public static final Color thistle;
   public static final Color tomato;
   public static final Color turquoise;
   public static final Color violet;
   public static final Color wheat;
   public static final Color white;
   public static final Color whitesmoke;
   public static final Color yellow;
   public static final Color yellowgreen;
   public Color(int red, int green, int blue);

   public Color(int red, int green, int blue, double alpha);

   public static int randomColor();

   public static int randomColor(int minimumBrightness);

   public static int randomColor(int minimumBrightness, int maximumBrightness);

   public final String toString();

   public final int toInt();

   public final boolean equals(Color otherColor);

   public final int getRed();

   public final int getGreen();

   public final int getBlue();

   public static int fromRGB(int red, int green, int blue);

   public static String fromRGBA(int red, int green, int blue, double alpha);

   public static String fromHSLA(double hue, double saturation, double luminance, double alpha);

   public static int fromHSL(double hue, double saturation, double luminance);

}

/**
 * Klassen, die dieses Interface implementieren, haben eine Methode compareTo, mit der sich zwei Objekte der Klasse vergleichen
 * lassen.
 **/
public interface Comparable<T> {
   /**
    * Vergleicht das Objekt mit dem übergebenen Objekt. Liefert eine negative Zahl zurück, wenn das Objekt 'kleiner' ist als das
    * übergebene, eine positive, falls es größer ist und 0, wenn beide Objekte gleich sind.
    **/
   public int compareTo(T object);

}

/**
 * A Comparator<T> is a object that can compare objects of class T.
 **/
public interface Comparator<T> {
   /**
    * Vergleicht die zwei angegebenen Objekte. Gibt eine negative Zahl zurück, falls das erste 'kleiner' ist als das zweite, eine
    * positive Zahl, falls es 'größer' ist und 0 falls die beiden Objekte 'gleich' sind.
    **/
   public int compare(T object1, T object2);

}

public class Cone3d {
   public Cone3d(double radius, double height, int radialSegments, int heightSegments, boolean openEnded, double thetaStart, double thetaLength);

   public Cone3d(double radius, double height, int radialSegments, int heightSegments, boolean openEnded);

   public Cone3d(double radius, double height);

   public Cone3d();

}

/**
 * Klasse zur Ausgabe von Objekten in der Konsole des Browsers.
 **/
public class Console {
   /**
    * Gibt das  in die Konsole des Browsers.
    **/
   public static void log(int value);

   /**
    * Gibt das  in die Konsole des Browsers.
    **/
   public static void log(long value);

   /**
    * Gibt das  in die Konsole des Browsers.
    **/
   public static void log(float value);

   /**
    * Gibt das  in die Konsole des Browsers.
    **/
   public static void log(double value);

   /**
    * Gibt das  in die Konsole des Browsers.
    **/
   public static void log(char value);

   /**
    * Gibt das  in die Konsole des Browsers.
    **/
   public static void log(boolean value);

   /**
    * Gibt das  in die Konsole des Browsers.
    **/
   public static void log(Object object);

}

public interface Consumer<T> {
   public void accept(T t);

}

/**
 * Die Klasse ArrayList ist eine Liste, deren Elemente in einem Array gespeichert sind. Wird das Array zu klein, kopiert die
 * ArrayList es automatisch in ein größeres Array.
 **/
public class CopyOnWriteArrayList<E> {
   /**
    * Instanziert (d.h. erzeugt) eine neue, leere Liste.
    **/
   public CopyOnWriteArrayList();

   /**
    * Gibt ein Iterator-Objekt zurück, mit dem über alle Elemente der Liste in der gespeicherten Reihenfolge iteriert werden kann.
    **/
   public Iterator<E> iterator();

   /**
    * Führt die angegebene Methode (Aktion) für jedes Element der ArrayList aus.
    * Tipp: Die Aktion kann in Lambda-Schreibweise angegeben werden, z.B. foreach((element) -> {...})
    **/
   public void forEach(Consumer<?> action);

   /**
    * Wandelt die Collection in ein Array um und gibt dieses zurück.
    **/
   public Object[] toArray();

   /**
    * Wandelt die Collection in ein Array um und gibt dieses zurück. Als Parameter muss ein Muster-Array übergeben werden, das den Typ
    * des zurückgegebenen Arrays bestimmt.
    **/
   public <T> T[] toArray(T[] a);

   /**
    * Fügt das übergebene Element ans Ende der Liste an.
    **/
   public boolean add(E e);

   /**
    * Fügt alle Elemente der übergebenen Collection ans Ende der Liste an.
    **/
   public boolean addAll(Collection<?> c);

   /**
    * Entleert die Liste. Die Liste ist nach Aufruf dieser Methode leer. Die Elemente der Liste werden dadurch nicht beeinträchtigt.
    **/
   public void clear();

   /**
    * Gibt genau dann true zurück, wenn die Liste das angegebene Element enthält.
    **/
   public boolean contains(E Element);

   /**
    * Gibt genau dann true zurück, wenn die Liste alle Elemente der übergebenen Collection enthält.
    **/
   public boolean containsAll(Collection<?> c);

   /**
    * Gibt genau dann true zurück, wenn die Liste leer ist, d.h. keine Elemente enthält.
    **/
   public boolean isEmpty();

   /**
    * Falls die Liste das übergebene Element enthält, entnimmt diese Methode der Liste das erste solche Element. Die Methode gibt
    * genau dann true zurück, wenn die Liste das Element enthalten hat.
    **/
   public boolean remove(E element);

   /**
    * Entnimnt der Liste alle Vorkommen aller Elemente der übergebenen Collection.
    **/
   public boolean removeAll(Collection<?> c);

   /**
    * Gibt die Anzahl der in der Liste enthaltenen Elemente zurück. Ist ein Element mehrfach enthalten, so wird es dabei mehrfach
    * gezählt.
    **/
   public int size();

   /**
    * Fügt das angegebene Element an der angegebenen Position in die Liste ein. Alle nachfolgendne Elemente werden um eine Position
    * nach hinten verschoben.
    **/
   public boolean add(int index, E element);

   /**
    * Fügt alle Elemente der übergebenen Collection an der angegebenen Position in die Liste ein. Alle nachfolgendne Elemente werden
    * entsprechend nach hinten verschoben.
    **/
   public boolean addAll(int index, Collection<?> c);

   /**
    * Gibt das Element an der angegebenen Position zurück.
    *  Das erste Element der Liste hat Position 0.
    **/
   public E get(int index);

   /**
    * Gibt den Index des angegebenen Elements in der Liste zurück. Falls das Element nicht in der Liste enthalten ist, wird -1
    * zurückgegeben.
    * Tipp: Das erste Element der Liste hat Index 0.
    **/
   public int indexOf(E Element);

   /**
    * Entfernt das Element mit dem angegebenen Index aus der Liste.
    * Tipp: Das erste Element der Liste hat Index 0.
    **/
   public E remove(int index);

   /**
    * Setzt das übergebene Element an der angegebenen Position in die Liste anstatt des bisher dort vorhandenen.
    **/
   public E set(int index, E Element);

   /**
    * Sortiert die Liste anhand des übergebenen Comparator-Objekts.
    **/
   public void sort(Comparator<?> comparator);

   /**
    * Wandelt das Objekt in eine Zeichenkette um und liefert diese zurück.
    **/
   public String toString();

}

public class Cylinder3d {
   public Cylinder3d(double radiusTop, double radiusBottom, double height, int radialSegments, int heightSegments, boolean openEnded, double thetaStart, double thetaLength);

   public Cylinder3d(double radiusTop, double radiusBottom, double height, int radialSegments, int heightSegments, boolean openEnded);

   public Cylinder3d(double radiusTop, double radiusBottom, double height);

   public Cylinder3d(double radius, double height);

   public Cylinder3d();

}

/**
 * Wochentag
 **/
public enum DayOfWeek {
   Montag, Dienstag, Mittwoch, Donnerstag, Freitag, Samstag, Sonntag;

   public static DayOfWeek[] values();

   public static DayOfWeek valueOf(String name);

}

/**
 * Die Klasse DecimalFormat wird zum Formatieren von Zahlen genutzt.
 **/
public class DecimalFormat {
   /**
    * Erzeugt ein neues DecimalFormat-Object. Zur Bedeutung von format siehe
    * https://docs.oracle.com/javase/8/docs/api/java/text/DecimalFormat.html
    **/
   public DecimalFormat(String format);

   /**
    * Die Methode Format gibt die Zahl formatiert als String zurück.
    **/
   public final String format(double number);

}

/**
 * Interface für Liste mit zweiseitigem Zugriff (insbesondere Anfügen an beiden Enden). Der Name steht für 'double ended queue' und
 * wird meist 'deck' ausgesprochen.
 **/
public interface Deque<E> {
   /**
    * Löscht das erste Vorkommen des Objekts. Gibt true zurück, wenn die Liste dadurch verändert wurde.
    **/
   public boolean removeFirstOccurrence(E element);

   /**
    * Löscht das letzte Vorkommen des Objekts. Gibt true zurück, wenn die Liste dadurch verändert wurde.
    **/
   public boolean removeLastOccurrence(E element);

   /**
    * Fügt das Element am Anfang der Liste ein.
    **/
   public void addFirst(E element);

   /**
    * Fügt das Element am Ende der Liste ein.
    **/
   public void addLast(E element);

   /**
    * Entfernt das Element am Anfang der Liste und gibt es zurück. Führt zum Fehler, wenn die Liste leer ist.
    **/
   public E removeFirst();

   /**
    * Entfernt das Element am Ende der Liste und gibt es zurück. Führt zum Fehler, wenn die Liste leer ist.
    **/
   public E removeLast();

   /**
    * Gibt das Element am Anfang der Liste zurück, entfernt es aber nicht. Gib null zurück, wenn die Liste leer ist.
    **/
   public E peekFirst();

   /**
    * Gibt das Element am Ende der Liste zurück, entfernt es aber nicht. Gib null zurück, wenn die Liste leer ist.
    **/
   public E peekLast();

   /**
    * Gibt das Element am Ende der Liste zurück und entfernt es von der Liste. Erzeugt einen Fehler, wenn die Liste leer ist.
    **/
   public E pop();

   /**
    * Fügt das Element am Ende der Liste hinzu.
    **/
   public void push(E element);

   /**
    * Gibt einen Iterator über die Elemente dieser Collection zurück, der die Liste in umgekehrter Reihenfolge (Ende -> Anfang)
    * durchläuft.
    **/
   public Iterator<E> descendingIterator();

}

/**
 * Richtung (top, right, bottom, left)
 **/
public enum Direction {
   top, right, bottom, left;

   public static Direction[] values();

   public static Direction valueOf(String name);

}

public class DirectionalLight3d {
   public DirectionalLight3d();

   public DirectionalLight3d(double x, double y, double z);

   public DirectionalLight3d(Vector3 position);

   public DirectionalLight3d setTarget(Object3d object3d);

}

public class Double {
   public static final int MAX_VALUE;
   public static final int POSITIVE_INFINITY;
   public static final int NEGATIVE_INFINITY;
   public static final int MIN_VALUE;
   public Double(double d);

   public final double doubleValue();

   public final float floatValue();

   public final int intValue();

   public final long longValue();

   public int compareTo(Double otherValue);

   public static double parseDouble(String s);

   public static Double valueOf(double f);

   public static Double valueOf(String s);

}

/**
 * Ellipse
 **/
public class Ellipse {
   /**
    * Instanziert einen neuen Ellipse mit Mittelpunkt (200, 100) und den Radien 100 und 50.
    **/
   public Ellipse();

   /**
    * Instanziert eine neuen Ellipse. (mx, my) ist der Mittelpunt, rx ihr Radius in x-Richtung, ry ihr Radius in y-Richtung.
    **/
   public Ellipse(double mx, double my, double rx, double ry);

   /**
    * Setzt den Radius der Ellipse in X-Richtung.
    **/
   public final void setRadiusX(double radiusX);

   /**
    * Gibt den x-Radius der Ellipse zurück.
    **/
   public final double getRadiusX();

   /**
    * Setzt den Radius der Ellipse in Y-Richtung.
    **/
   public final void setRadiusY(double radiusY);

   /**
    * Gibt den y-Radius der Ellipse zurück.
    **/
   public final double getRadiusY();

   /**
    * Erstellt eine Kopie des ellipse-Objekts und git sie zurück.
    **/
   public final Ellipse copy();

   /**
    * Gibt genau dann true zurück, wenn die Figur den angegebenen Punkt enthält.
    **/
   public final boolean containsPoint(double x, double y);

   /**
    * Wandelt das Objekt in eine Zeichenkette um und liefert diese zurück.
    **/
   public String toString();

}

public class EmptyStackException {
   public EmptyStackException();

   public EmptyStackException(String message);

   public EmptyStackException(Throwable cause);

   public EmptyStackException(String message, Throwable cause);

   public String toString();

}

public class Enum {
   public String name();

   public int ordinal();

   public String toString();

}

public class Exception {
   public Exception();

   public Exception(String message);

   public Exception(Throwable cause);

   public Exception(String message, Throwable cause);

   public String toString();

}

/**
 * Klasse mit statischen Methoden zum Lesen/Schreiben von Dateien.
 **/
public class Files {
   /**
    * Gibt den Inhalt der Workspacedatei zurück.
    **/
   public static String read(String filename);

   /**
    * Schreibt den Text in die Workspacedatei.
    **/
   public static void write(String filename, String text);

   /**
    * Fügt den Text hinten an die Workspacedatei an.
    **/
   public static void append(String filename, String text);

}

public class FilledShape {
   public FilledShape();

   /**
    * Gibt die Füllfarbe dieses Objekts als Color-Objekt zurück.
    **/
   public Color getFillColor();

   /**
    * Gibt die Füllfarbe dieses Objekts als Color-Objekt zurück.
    **/
   public int getFillColorAsInt();

   /**
    * Setzt die Füllfarbe des Objekts. Die Farbe wird als Color-Objekt angegeben.
    **/
   public void setFillColor(Color color);

   /**
    * Setzt die Füllfarbe des Objekts. Die Farbe wird als Color-Objekt angegeben.
    **/
   public void setFillColor(Color color, double alpha);

   /**
    * Setzt die Füllfarbe des Objekts. Die Farbe wird als integer-Wert angegeben.
    *  Tipp: Schreibe die Farbe in der Form 0xffffff, dann zeigt die IDE ein kleines Farbquadrat, mit dem Du einen Color Picker öffnen
    * kannst.
    **/
   public void setFillColor(int color);

   /**
    * Setzt die Füllfarbe des Objekts. Die Farbe wird als integer-Wert angegeben, der alpha-Wert (Durchsichtigkeit) als double-Wert.
    * 0.0 bedeutet komplett durchsichtig, 1.0 bedeutet kompett undurchsichtig.
    *  Tipp: Schreibe die Farbe in der Form 0xffffff, dann zeigt die IDE ein kleines Farbquadrat, mit dem Du einen Color Picker öffnen
    * kannst.
    **/
   public void setFillColor(int color, double alpha);

   /**
    * Setzt die Füllfarbe des Objekts. Die Farbe wird als Zeichenkette angegeben. Möglich sind Farbkonstanten ("rot", "red", ...) oder
    * css-Syntax wie "#ff034a", "rgb(100, 200, 10)" oder "rgba(100, 10, 10, 0.8)".
    **/
   public void setFillColor(String color);

   /**
    * Setzt die Füllfarbe des Objekts. Die Farbe wird als Zeichenkette angegeben, der Alpha-Wert (Undurchsichtigkeit) als double-Wert
    * zwischen 0.0 (komplett durchsichtig) und 1.0 (komplett undurchsichtig). Möglich sind Farbkonstanten ("rot", "red", ...) oder
    * css-Syntax wie "#ff034a", "rgb(100, 200, 10)" oder "rgba(100, 10, 10, 0.8)".
    **/
   public void setFillColor(String color, double alpha);

   /**
    * Gibt die Randfarbe dieses Objekts als Color-Objekt zurück.
    **/
   public Color getBorderColor();

   /**
    * Gibt die Randfarbe dieses Objekts als Color-Objekt zurück.
    **/
   public int getBorderColorAsInt();

   /**
    * Setzt die Randfarbe des Objekts. Die Farbe wird als Color-Objekt angegeben.
    **/
   public void setBorderColor(Color color);

   /**
    * Setzt die Randfarbe des Objekts. Die Farbe wird als Color-Objekt angegeben.
    **/
   public void setBorderColor(Color color, double alpha);

   /**
    * Setzt die Randfarbe des Objekts. Die Farbe wird als integer-Wert angegeben.
    *  Tipp: Schreibe die Farbe in der Form 0xffffff, dann zeigt die IDE ein kleines Farbquadrat, mit dem Du einen Color Picker öffnen
    * kannst.
    **/
   public void setBorderColor(int color);

   /**
    * Setzt die Randfarbe des Objekts. Die Farbe wird als integer-Wert angegeben, der alpha-Wert (Durchsichtigkeit) als double-Wert.
    * 0.0 bedeutet komplett durchsichtig, 1.0 bedeutet kompett undurchsichtig.
    *  Tipp: Schreibe die Farbe in der Form 0xffffff, dann zeigt die IDE ein kleines Farbquadrat, mit dem Du einen Color Picker öffnen
    * kannst.
    **/
   public void setBorderColor(int color, double alpha);

   /**
    * Setzt die Randfarbe des Objekts. Die Farbe wird als Zeichenkette angegeben. Möglich sind Farbkonstanten ("rot", "red", ...) oder
    * css-Syntax wie "#ff034a", "rgb(100, 200, 10)" oder "rgba(100, 10, 10, 0.8)".
    **/
   public void setBorderColor(String color);

   /**
    * Setzt die Randfarbe des Objekts. Die Farbe wird als Zeichenkette angegeben, der Alpha-Wert (Undurchsichtigkeit) als double-Wert
    * zwischen 0.0 (komplett durchsichtig) und 1.0 (komplett undurchsichtig). Möglich sind Farbkonstanten ("rot", "red", ...) oder
    * css-Syntax wie "#ff034a", "rgb(100, 200, 10)" oder "rgba(100, 10, 10, 0.8)".
    **/
   public void setBorderColor(String color, double alpha);

   /**
    * Setzt die Randbreite des Objekts in Pixeln.
    **/
   public void setBorderWidth(double width);

   /**
    * Gibt die Randbreite dieses Objekts in Pixeln zurück.
    **/
   public double getBorderWidth();

   /**
    * Setzt den Alphy-Wert des Objekts. Dabei bedeutet 0.0 ganz durchsichtig, 1.0 ganz undurchsichtig.
    **/
   public void setAlpha(double alpha);

   /**
    * Gibt den Alphy-Wert des Objekts zurück. Dabei bedeutet 0.0 ganz durchsichtig, 1.0 ganz undurchsichtig.
    **/
   public double getAlpha();

   /**
    * Setzt die Default-Werte für Randbreite und Randfarbe. Allen danach neu erzeugten Objekten werden anfangs diese Eigenschaften
    * zugewiesen.
    **/
   public static void setDefaultBorder(double width, String color);

   /**
    * Setzt die Default-Werte für Randbreite, Randfarbe und alpha-Wert (Durchsichtigkeit). Allen danach neu erzeugten Objekten werden
    * anfangs diese Eigenschaften zugewiesen.
    **/
   public static void setDefaultBorder(double width, int color, double alpha);

   /**
    * Setzt den Defaultwert für die Füllfarbe. Allen danach neu erzeugten Objekten wird anfangs diese Eigenschaft zugewiesen.
    **/
   public static void setDefaultBorder(String color);

   /**
    * Setzt den Defaultwert für die Füllfarbe. Allen danach neu erzeugten Objekten wird anfangs diese Eigenschaft zugewiesen.
    **/
   public static void setDefaultBorder(int color, double alpha);

}

public class Float {
   public static final int MAX_VALUE;
   public static final int MIN_VALUE;
   public static final int POSITIVE_INFINITY;
   public static final int NEGATIVE_INFINITY;
   public Float(float d);

   public final double doubleValue();

   public final float floatValue();

   public final int intValue();

   public final long longValue();

   public int compareTo(Float otherValue);

   public static float parseFloat(String s);

   public static Float valueOf(float f);

   public static Float valueOf(String s);

}

public interface Function<E, F> {
   public F apply(E e);

}

/**
 * Klasse mit statischen Methoden zur Abfrage der Gamepads.
 **/
public class Gamepad {
   /**
    * Gibt genau dann true zurück, wenn der Button buttonIndex des Gamepads GamepadIndex gedrückt ist. VORSICHT: Das erste Gamepad hat
    * Index 0.
    **/
   public static boolean isButtonDown(int gamepadIndex, int buttonIndex);

   /**
    * Gibt true zurück, falls das Gamepad mit dem übergebenen Index angeschlossen ist. VORSICHT: Das erste Gamepad hat Index 0.
    **/
   public static boolean isConnected(int gamepadIndex);

   /**
    * Gibt den Wert des Gamepad-Steuerknüppels mit Index axisIndex zurück.
    **/
   public static double getAxisValue(int gamepadIndex, int axisIndex);

}

/**
 * Eine Gruppe kann mehrere graphische Objekte (auch andere Gruppen) enthalten und miteinander verschieben, drehen, ...
 **/
public class Group<T extends Shape> {
   /**
    * Erstellt eine neue Gruppe
    **/
   public Group();

   /**
    * Erstellt eine neue Gruppe
    **/
   public Group(T[] shapes);

   /**
    * Fügt der Gruppe graphische Elemente hinzu. Tipp: Diese Methode kann beliebig viele Parameter haben.
    **/
   public final void add(T shape);

   /**
    * Fügt der Gruppe graphische Elemente hinzu. Tipp: Diese Methode kann beliebig viele Parameter haben.
    **/
   public final void add(T[] shapes);

   /**
    * Entfernt das übergebene Objekt aus der Gruppe. Das Objekt wird dadurch nicht verändert.
    **/
   public final void remove(T shape);

   /**
    * Entfernt das Element mit dem gegebenen Index aus der Gruppe. Das erste Element hat Index 0.
    **/
   public final void remove(int index);

   /**
    * Gibt das Element mit dem angegebenen Index zurück. Das erste Element der Gruppe hat Index 0.
    **/
   public final T get(int index);

   /**
    * Gibt den Index des elements innerhalb der Gruppe zurück. Falls das Element nicht in der Gruppe enthalten ist, wird -1
    * zurückgegeben.
    **/
   public final int indexOf(T shape);

   /**
    * Gibt die Anzahl der Elemente in dieser Gruppe zurück.
    **/
   public final int size();

   /**
    * Leert die Gruppe. Die in der Gruppe enthaltenen Elemente werden dadurch nicht verändert.
    **/
   public final void empty();

   /**
    * Zerstört alle Elemente der Gruppe, nicht aber die Gruppe selbst.
    **/
   public final void destroyAllChildren();

   /**
    * Erstellt eine Bitmap (Textur) und zeichnet alle in der Gruppe enthaltenen Elemente darauf. Zeichnet ab diesem Zeitpunkt statt
    * der enthaltenen Elemente nur noch die Bitmap (=> schneller!). Alle enthaltenen Elemente werden bei dieser Operation zerstört.
    **/
   public final void renderAsStaticBitmap();

   /**
    * Erstellt eine Kopie dieser Gruppe inclusive Kopien aller ihrer Elemente.
    **/
   public final Group<T> copy();

   /**
    * Gibt die Elemente der Gruppe zurück, die mit dem übergebenen Shape kollidieren.
    **/
   public final T[] getCollidingShapes(Shape otherShape);

   /**
    * Überprüft, welche Objekte der Gruppe mit welchen der anderen kollidieren. Gibt für jede Kollision ein Collisionpair-Objekt
    * zurück, das die beiden kollidierenden Objekte enthält. Falls maxOneCollisionPerShape == true ist jedes Objekt dabei aber nur in
    * max. einem Collisionpair-Objekt enthalten.
    **/
   public final <V extends Shape> CollisionPair<T, V>[] getCollisionPairs(Group<V> otherGroup, boolean maxOneCollisionPerShape);

   /**
    * Gibt genau dann true zurück, wenn die Figur mit der anderen Figur überlappt.
    **/
   public final boolean collidesWith(Shape otherShape);

   /**
    * Gibt genau dann true zurück, wenn die Figur mit irgendeiner anderen Figur überlappt.
    **/
   public final boolean collidesWithAnyShape();

   /**
    * Gibt genau dann true zurück, wenn die Figur mit irgendeiner anderen Figur mit der angegebenen Füllfarbe überlappt.
    **/
   public final boolean collidesWithFillColor(int color);

   /**
    * Gibt genau dann true zurück, wenn die Figur mit irgendeiner anderen Figur mit der angegebenen Füllfarbe überlappt.
    **/
   public final boolean collidesWithFillColor(String color);

   /**
    * Gibt genau dann true zurück, wenn die Figur mit irgendeiner anderen Figur mit der angegebenen Füllfarbe überlappt.
    **/
   public final boolean collidesWithFillColor(Color color);

   /**
    * Falls dieses Grafikobjekt gerade mindestens ein Sprite mit dem übergebenen Bildindex (-1 bedeutet: mit irgendeinem BildIndex)
    * berührt, wird das erste dieser Sprites zurückgegeben.
    **/
   public final Sprite getFirstCollidingSprite(int imageIndex);

}

/**
 * Ein Group3d-Objekt gruppiert mehrere 3d-Objekte zusammen, so dass sie miteinander gedreht verschoben, ... werden können.
 **/
public class Group3d<O3d extends Object3d> {
   public Group3d();

   public void move(double x, double y, double z);

   public final void move(Vector3 v);

   public void moveTo(double x, double y, double z);

   public final void moveTo(Vector3 p);

   public void rotateX(double angleDeg);

   public void rotateY(double angleDeg);

   public void rotateZ(double angleDeg);

   public final void scaleX(double angleDeg);

   public final void scaleY(double angleDeg);

   public final void scaleZ(double angleDeg);

   public final void scale(Vector3 v);

   public final void scale(double d);

   public final void applyMatrix4(Matrix4 matrix);

   /**
    * Fügt der Gruppe ein 3d-Objekt hinzu.
    **/
   public final void add(O3d object);

   /**
    * Entfernt ein 3d-Objekt aus dieser Gruppe.
    **/
   public final void remove(O3d object);

   /**
    * Gibt die Anzahl der 3d-Objekte in dieser Gruppe zurück.
    **/
   public final int size();

   /**
    * Gibt das Element mit dem gegebenen Index zurück. Das erste Element hat Index 0.
    **/
   public final O3d get(int index);

   public void destroy();

}

/**
 * Listener-Interface für GUI-Klassen (Button, TextField, Checkbox, Radiobutton)
 **/
public interface GuiChangeListener {
   /**
    * Wird immer dann aufgerufen, wenn sich das GUI-Objekt verändert hat.
    **/
   public void onChange(Object changedObject, String newValue);

}

/**
 * Oberklasse für alle GUI-Komponenten
 **/
public class GuiComponent {
   public GuiComponent();

   /**
    * Fügt einen ChangeListener hinzu, dessen onChange-Methode immer dann aufgerufen wird, wenn sich der Wert der GUI-Komponente
    * aufgrund von Benutzeraktionen ändert.
    **/
   public void addChangeListener(GuiChangeListener changeListener);

   /**
    * Gibt die Breite des GUI-Objekts zurück.
    **/
   public final double getWidth();

   /**
    * Gibt die Höhe des GUI-Objekts zurück.
    **/
   public final double getHeight();

   /**
    * Wird aufgerufen, wenn sich der Wert der GUI-Komponente aufgrund von Benutzeraktionen ändert.
    **/
   public void onChange(String newValue);

}

/**
 * Abstrakte Oberklasse für alle Gui-Komponenten mit Textanteil
 **/
public class GuiTextComponent {
   public GuiTextComponent();

   /**
    * Setzt die Schriftgröße des Textes (Einheit: Pixel).
    **/
   public void setFontsize(double fontsize);

   /**
    * Setzt den Text.
    **/
   public void setText(String text);

   /**
    * Gibt den Text zurück.
    **/
   public String getText();

   /**
    * Gibt die Schriftgröße zurück.
    **/
   public double getFontsize();

   /**
    * Setzt die Eigenschaften Fettdruck (bold) und Schrägschrift (italic).
    **/
   public void setStyle(boolean isBold, boolean isItalic);

   /**
    * Setzt die Textfarbe. Die Farbe wird als int-Wert gegeben, wobei farbe == 256*256*rot + 256*grün + blau
    **/
   public void setTextColor(int color);

}

/**
 * JavaHamster-Hamster
 **/
public class Hamster {
   public static int NORD;
   public static int OST;
   public static int SÜD;
   public static int WEST;
   /**
    * Instanziert ein neues Hamster-Objekt
    **/
   public Hamster(JavaHamsterWorld world, int reihe, int spalte, int blickrichtung, int anzahlkörner);

   /**
    * Bewegt den Hamster um ein Feld nach vorne.
    **/
   public final void vor();

   /**
    * Gibt das JavaHamsterWorld-Objekt zurück, in dem sich Hamster befindet.
    **/
   public final JavaHamsterWorld getWorld();

   /**
    * Gibt die Blickrichtung von Hamster zurück: 0 == Norden, 1 == Osten, 2 == Süden, 3 == Westen
    **/
   public final int getBlickrichtung();

   /**
    * Gibt die Reihe zurück, in der sich der Hamster gerade befindet. Reihe 0 ist ganz oben.
    **/
   public final int getReihe();

   /**
    * Gibt die Spalte zurück, in der sich der Hamster gerade befindet. Reihe 0 ist ganz links.
    **/
   public final int getSpalte();

   /**
    * Gibt die Anzahl der Körner zurück, die der Hamster gerade im Mund hat.
    **/
   public final int getAnzahlKoerner();

   /**
    * Dreht Hamster um 90° nach links
    **/
   public final void linksUm();

   /**
    * Der Hamster legt ein Korn in der Zelle ab, in der er sich gerade befindet.
    **/
   public final void gib();

   /**
    * Der Hamster nimmt ein Korn aus der Zelle, in der er sich gerade befindet.
    **/
   public final void nimm();

   /**
    * Liefert genau dann true, wenn sich in Blickrichtung vor dem aufgerufenen Hamster keine Mauer befindet (wenn sich der Hamster in
    * Blickrichtung am Rand des Territoriums befindet, wird false geliefert)
    **/
   public final boolean vornFrei();

   /**
    * Liefert genau dann true, wenn der Hamster keine Körner im Mund hat.
    **/
   public final boolean maulLeer();

   /**
    * Liefert genau dann true, wenn sich in der Zelle, auf der der Hamster sich befindet, mindestens ein Korn befindet.
    **/
   public final boolean kornDa();

   /**
    * Gibt den Text auf dem Bildschirm aus.
    **/
   public final void schreib(String text);

}

/**
 * Map-Klasse mit Zugriffszeit proportional zu log(Anzahl der Elemente)
 **/
public class HashMap<K, V> {
   /**
    * Erstellt ein neues HashMap-Objekt
    **/
   public HashMap();

   /**
    * Gibt die Anzahl der Schlüssel-Wert-Paare der Map zurück.
    **/
   public int size();

   /**
    * Gibt genau dann true zurück, wenn die Map keine Schlüssel-Wert-Paare enthält.
    **/
   public boolean isEmpty();

   /**
    * Gibt genau dann true zurück, wenn die Map zum Schlüssel key einen Wert enthält.
    **/
   public boolean containsKey(K key);

   /**
    * Gibt genau dann true zurück, wenn die Map den Wert enthält.
    **/
   public boolean containsValue(V value);

   /**
    * Gibt den Wert zum Schlüssel key zurück. Gibt null zurück, falls die Map zum Schlüssel key keinen Wert enthält.
    **/
   public V get(K key);

   /**
    * Speichert das key-value pair in der Map. Falls zum key vorher schon ein Value gespeichert war, wird dieser zurückgegeben. In der
    * Map wird er dann durch den neuen Value überschrieben. Falls es zum key noch keinen value in der Map gab, wird null
    * zurückgegeben.
    **/
   public V put(K key, V value);

   /**
    * Entfernt alle Schlüssel-Wert-Paare aus der Map.
    **/
   public void clear();

   /**
    * Führt die angegebene Aktion für jedes Schlüssel-Wert-Paar dieser Map aus.
    **/
   public void forEach(BiConsumer<?, ?> action);

   /**
    * Gibt eine Collection zurück, die alle Werte der Map enthält (ggf. auch mehrfach).
    **/
   public Collection<V> values();

   /**
    * Gibt ein Set zurück, das alle Schlüssel dieser Map enthält.
    **/
   public Set<K> keySet();

   /**
    * Entfernt das Mapping für den gegebenen Schlüssel (falls vorhanden). Gibt ggf. den zu diesem Schlüssel gespeicherten Wert zurück
    * oder null, falls zum Schlüssel kein Wert gespeichert war.
    **/
   public V remove(K key);

   /**
    * Entfernt das Mapping für den gegebenen Schlüssel (falls vorhanden). Gibt ggf. den zu diesem Schlüssel gespeicherten Wert zurück
    * oder null, falls zum Schlüssel kein Wert gespeichert war.
    **/
   public boolean remove(K key, V value);

   /**
    * Wandelt das Objekt in eine Zeichenkette um und liefert diese zurück.
    **/
   public String toString();

}

/**
 * Set mit konstanter Zugriffszeit
 **/
public class HashSet<E> {
   /**
    * Erstellt ein neues HashSet-Objekt.
    **/
   public HashSet();

   /**
    * Gibt ein Iterator-Objekt für dieses Iterable-Objekt zurück.
    **/
   public Iterator<E> iterator();

   /**
    * Führt die angegebene Aktion für jedes Element dieses Iterable-Objekts aus.
    **/
   public void forEach(Consumer<?> action);

   /**
    * Fügt das übergebene Element ans Ende der Liste an.
    **/
   public boolean add(E e);

   /**
    * Fügt alle Elemente der übergebenen Collection ans Ende der Liste an.
    **/
   public boolean addAll(Collection<?> c);

   /**
    * Entleert die Liste. Die Liste ist nach Aufruf dieser Methode leer. Die Elemente der Liste werden dadurch nicht beeinträchtigt.
    **/
   public void clear();

   /**
    * Gibt genau dann true zurück, wenn die Liste das angegebene Element enthält.
    **/
   public boolean contains(E element);

   /**
    * Gibt genau dann true zurück, wenn die Liste alle Elemente der übergebenen Collection enthält.
    **/
   public boolean containsAll(Collection<?> c);

   /**
    * Gibt genau dann true zurück, wenn die Liste leer ist, d.h. keine Elemente enthält.
    **/
   public boolean isEmpty();

   /**
    * Falls die Liste das übergebene Element enthält, entnimmt diese Methode der Liste das erste solche Element. Die Methode gibt
    * genau dann true zurück, wenn die Liste das Element enthalten hat.
    **/
   public boolean remove(E element);

   /**
    * Entnimnt der Liste alle Vorkommen aller Elemente der übergebenen Collection.
    **/
   public boolean removeAll(Collection<?> c);

   /**
    * Gibt die Anzahl der in der Liste enthaltenen Elemente zurück. Ist ein Element mehrfach enthalten, so wird es dabei mehrfach
    * gezählt.
    **/
   public int size();

   /**
    * Wandelt die Collection in ein Array um und gibt dieses zurück.
    **/
   public Object[] toArray();

   /**
    * Wandelt die Collection in ein Array um und gibt dieses zurück. Als Parameter muss ein Muster-Array übergeben werden, das den Typ
    * des zurückgegebenen Arrays bestimmt.
    **/
   public <T> T[] toArray(T[] a);

   /**
    * Wandelt das Objekt in eine Zeichenkette um und liefert diese zurück.
    **/
   public String toString();

}

/**
 * Ein Objekt der Klasse HttpClient kann Http-Requests senden.
 **/
public class HttpClient {
   /**
    * Instanziert ein neues HttpClient-Objekt.
    **/
   public HttpClient();

   /**
    * Sendet den Request an den Server.
    **/
   public HttpResponse send(HttpRequest request);

}

/**
 * Ein Http-Header ist ein Schlüssel-Wert-Paar (key-value-pair).
 **/
public class HttpHeader {
   /**
    * Schlüssel (key) des Http-Headers
    **/
   public String key;
   /**
    * Wert (value) des Http-Headers
    **/
   public String value;
}

/**
 * Ein Objekt der Klasse HttpRequest umfasst die URI, den Header und die Daten eines Http-Requests.
 **/
public class HttpRequest {
   /**
    * Instanziert ein neues HttpRequest-Objekt.
    **/
   public HttpRequest();

   /**
    * Legt die URI des Requests fest. Gibt ein HttpRequest-Objekt zurück (zum method-chaining).
    **/
   public HttpRequest uri(String uri);

   /**
    * Fügt dem Request einen Header hinzu.
    **/
   public HttpRequest header(String key, String value);

   /**
    * Setzt die Request-Methode auf POST und fügt dem Request die übergebenen Daten hinzu.
    **/
   public HttpRequest POST(String data);

   /**
    * Setzt die Request-Methode auf GET.
    **/
   public HttpRequest GET(String data);

}

/**
 * Ein Objekt der Klasse HttpResponse umfasst den Statuscode, die Header und den Body (d.h. die Daten) eines http-Response.
 **/
public class HttpResponse {
   /**
    * Gibt die URI des Responses zurück.
    **/
   public String uri();

   /**
    * Gibt den Body dieses Responses zurück.
    **/
   public String body();

   /**
    * Gibt den Statuscode dieses Responses zurück.
    **/
   public int statusCode();

   /**
    * Gibt den den http-Status dieses Responses in Textform zurück.
    **/
   public String statusText();

   /**
    * Gibt das Request-Objekt zurück, das diesen Response zur Folge hatte.
    **/
   public HttpRequest request();

   /**
    * Gibt die Header dieses Responses zurück.
    **/
   public HttpHeader[] headers();

}

public class Icosahedron3d {
   public Icosahedron3d(double radius, int detail);

   public Icosahedron3d(double radius);

   public Icosahedron3d();

}

public class IllegalMonitorStateException {
}

public class IndexOutOfBoundsException {
}

/**
 * Klasse mit statischen Methoden zur Eingabe von Text per Tastatur
 **/
public class Input {
   /**
    * Erwartet vom Benutzer die Eingabe eines Wertes vom Datentyp String
    **/
   public static String readString(String message, String defaultValue);

   /**
    * Erwartet vom Benutzer die Eingabe eines Wertes vom Datentyp String
    **/
   public static String readString(String message);

   /**
    * Erwartet vom Benutzer die Eingabe eines Wertes vom Datentyp boolean
    **/
   public static boolean readBoolean(String message, boolean defaultValue);

   /**
    * Erwartet vom Benutzer die Eingabe eines Wertes vom Datentyp boolean
    **/
   public static boolean readBoolean(String message);

   /**
    * Erwartet vom Benutzer die Eingabe eines Wertes vom Datentyp int
    **/
   public static int readInt(String message, int defaultValue);

   /**
    * Erwartet vom Benutzer die Eingabe eines Wertes vom Datentyp int
    **/
   public static int readInt(String message);

   /**
    * Erwartet vom Benutzer die Eingabe eines Wertes vom Datentyp float
    **/
   public static float readFloat(String message, float defaultValue);

   /**
    * Erwartet vom Benutzer die Eingabe eines Wertes vom Datentyp float
    **/
   public static float readFloat(String message);

   /**
    * Erwartet vom Benutzer die Eingabe eines Wertes vom Datentyp double
    **/
   public static int readDouble(String message, double defaultValue);

   /**
    * Erwartet vom Benutzer die Eingabe eines Wertes vom Datentyp double
    **/
   public static double readDouble(String message);

   /**
    * Erwartet vom Benutzer die Eingabe eines Wertes vom Datentyp char
    **/
   public static char readChar(String message, char defaultValue);

   /**
    * Erwartet vom Benutzer die Eingabe eines Wertes vom Datentyp char
    **/
   public static char readChar(String message);

   /**
    * Wartet, bis die Benutzerin/der Benutzer eine der angegebenen Tasten gedrückt hat.
    **/
   public static String waitForKey(String[] possibleKeys);

   /**
    * Wartet, bis die Benutzerin/der Benutzer eine beliebige Taste gedrückt hat.
    **/
   public static String waitForKey();

   /**
    * Gibt genau dann true zurück, wenn die angegebene Taste gerade heruntergedrückt ist. N.B.: Für Sondertasten gibt es die
    * vordefinierten statische Konstanten der Klasse Key, z.B. prüft Input.isKeyDown(Key.ArrowLeft), ob gerade die
    * Pfeil-nach-links-Taste heruntergedrückt ist. 
    **/
   public static boolean isKeyDown(String key);

}

public class Integer {
   public static final int MAX_VALUE;
   public static final int MIN_VALUE;
   public Integer(int value);

   public Integer(String value);

   public final double doubleValue();

   public final float floatValue();

   public final int intValue();

   public final long longValue();

   public int compareTo(Integer anotherInteger);

   public static int parseInt(String s);

   public static int parseInt(String sr, int radix);

   public static Integer valueOf(int i);

   public static Integer valueOf(String s);

   public static Integer valueOf(String s, int radix);

}

/**
 * Objekte von Klassen, die dieses Interface implementieren, können in einer vereinfachten for-loop (for(object o: list){...})
 * verwendet werden.
 **/
public interface Iterable<T> {
   /**
    * Gibt ein Iterator-Objekt für dieses Iterable-Objekt zurück.
    **/
   public Iterator<T> iterator();

   /**
    * Führt die angegebene Aktion für jedes Element dieses Iterable-Objekts aus.
    **/
   public void forEach(Consumer<?> action);

}

/**
 * Ein Iterator ist ein Objekt, das die Elemente einer Liste der Reihe nach einzeln liefern kann.
 **/
public interface Iterator<E> {
   /**
    * Liefert true zurück falls es noch weitere Elemente gibt, die mit der Methoe next() abgerufen werden können.
    **/
   public boolean hasNext();

   /**
    * Liefert das nächste Element.
    **/
   public E next();

}

/**
 * JavaHamster-Welt
 **/
public class JavaHamsterWorld {
   /**
    * Instanziert eine neue JavaHamster-Welt
    **/
   public JavaHamsterWorld(int Breite, int Höhe);

   /**
    * Gibt zurück, wie viele Felder breit die Welt ist.
    **/
   public final int getBreite();

   /**
    * Gibt zurück, wie viele Felder hoch die Welt ist.
    **/
   public final int getHöhe();

   /**
    * Löscht alles aus der Welt bis auf den Hamster.
    **/
   public final void löscheAlles();

   /**
    * Setzt oder entfernt an der Position (x, y) eine Mauer.
    **/
   public final void setzeMauer(int x, int y);

   /**
    * Setzt an der Position (x, y) die Anzahl der Getreidekörner.
    **/
   public final void setzeGetreide(int x, int y, int anzahl);

   /**
    * Baut die Welt mithilfe eines mehrzeiligen Strings. Dabei bedeutet \n einen Zeilenumbruch, m eine Mauer und 1 ... 9, a ... f die
    * entsprechende Anzahl an Getreidekörnern.
    **/
   public final void init(String worldAsString);

   /**
    * Streckt das Grafikobjekt um den angegebenen Faktor. Das Zentrum der Streckung ist der Punkt (centerX, centerY)
    **/
   public final void scale(double factor);

}

/**
 * JavaKara-Welt
 **/
public class JavaKaraWorld {
   public static int NORTH;
   public static int WEST;
   public static int SOUTH;
   public static int EAST;
   /**
    * Missing template for language de
    **/
   public JavaKaraWorld(int sizeX, int sizeY);

   /**
    * Gibt zurück, wie viele Felder breit die Welt ist.
    **/
   public final int getSizeX();

   /**
    * Gibt zurück, wie viele Felder hoch die Welt ist.
    **/
   public final int getSizeY();

   /**
    * Löscht alles aus der Welt bis auf Kara.
    **/
   public final void clearAll();

   /**
    * Setzt oder entfernt an der Position (x, y) ein Kleeblatt.
    **/
   public final void setLeaf(int x, int y);

   /**
    * Setzt oder entfernt an der Position (x, y) einen Baumstumpf.
    **/
   public final void setTree(int x, int y);

   /**
    * Setzt oder entfernt an der Position (x, y) einen Pilz.
    **/
   public final void setMushroom(int x, int y);

   /**
    * Gibt genau dann true zurück, wenn sich auf dem angegebenen Feld nichts befindet (auch nicht Kara).
    **/
   public final boolean isEmpty(int x, int y);

   /**
    * Baut die Welt mithilfe eines mehrzeiligen Strings. Dabei bedeutet \n einen Zeilenumbruch, l ein Kleeblatt, t einen Baumstumpf
    * und m einen Pilz.
    **/
   public final void init(String s);

   /**
    * Streckt das Grafikobjekt um den angegebenen Faktor. Das Zentrum der Streckung ist der Punkt (centerX, centerY)
    **/
   public final void scale(double factor);

}

/**
 * Repräsentiert einen Knoten in einem Json-Objektbaum.
 **/
public class JsonElement {
   /**
    * Gibt den Typ des Json-Elements zurück. Mögliche Werte sind "string", "number", "array", "boolean" und "object".
    **/
   public String getType();

   /**
    * Falls das Json-Element ein Objekt ist, gibt diese Funktion den Wert seines Attributs mit dem übergebenen Bezeichner als
    * JsonElement zurück.
    **/
   public JsonElement getAttributeValue(String identifier);

   /**
    * Falls das Json-Element ein Array ist, gibt diese Funktion es als Array von Json-Elementen zurück, andernfalls wirft sie eine
    * Exception.
    **/
   public JsonElement[] getArrayValues();

   /**
    * Falls das Json-Element ein Objekt ist, gibt diese Funktion den Wert seines Attributs mit dem übergebenen Bezeichner als
    * JsonElement zurück.
    **/
   public JsonElement getArrayValue(String identifier);

   /**
    * Gibt den String-Wert des JSon-Elements zurück.
    **/
   public String getAsString();

   /**
    * Gibt den String-Wert des JSon-Elements zurück.
    **/
   public String getAsString(String identifier);

   /**
    * Gibt den int-Wert des JSon-Elements zurück.
    **/
   public int getAsInt();

   /**
    * Gibt den int-Wert des JSon-Elements zurück.
    **/
   public int getAsInt(String identifier);

   /**
    * Gibt den double-Wert des JSon-Elements zurück.
    **/
   public double getAsDouble();

   /**
    * Gibt den double-Wert des JSon-Elements zurück.
    **/
   public double getAsDouble(String identifier);

   /**
    * Gibt den boolean-Wert des JSon-Elements zurück.
    **/
   public boolean getAsBoolean();

   /**
    * Gibt den boolean-Wert des JSon-Elements zurück.
    **/
   public boolean getAsBoolean(String identifier);

   /**
    * Gibt den Wert des Json-Elements als Json-codierten String zurück.
    **/
   public String toJson();

   /**
    * Falls das Json-Element ein Objekt ist, gibt diese Funktion ein Array mit seinen Attributbezeichnern zurück.
    **/
   public String[] getAttributeIdentifiers();

}

/**
 * Parst Json-Code und gibt ihn als Objektbaum zurück.
 **/
public class JsonParser {
   /**
    * Wandelt einen Json-String in einen Objektbaum um.
    **/
   public static JsonElement parse(String jsonString);

}

/**
 * JavaKara-Marienkäfer
 **/
public class Kara {
   /**
    * Instanziert ein neues Kara-Objekt.
    **/
   public Kara(JavaKaraWorld world, int x, int y, int direction);

   /**
    * Gibt Karas Position zurück. Dabei ist (0/0) die Position der linken oberen Ecke.
    **/
   public final Position getPosition();

   /**
    * Bewegt Kara um ein Feld nach vorne.
    **/
   public final void move();

   /**
    * Gibt das JavaKaraWorld-Objekt zurück, in dem sich Kara befindet.
    **/
   public final JavaKaraWorld getWorld();

   /**
    * Gibt die Blickrichtung von Kara zurück: 0 == Norden, 1 == Westen, 2 == Süden, 3 == Osten
    **/
   public final int getDirection();

   /**
    * Gibt genau dann true zurück, wenn sich Kara auf einem Kleeblatt befindet.
    **/
   public final boolean onLeaf();

   /**
    * Gibt genau dann true zurück, wenn sich vor Kara ein Baumstumpf befindet.
    **/
   public final boolean treeFront();

   /**
    * Gibt genau dann true zurück, wenn sich auf dem Feld unmmittelbar links von Kara ein Baumstumpf befindet.
    **/
   public final boolean treeLeft();

   /**
    * Gibt genau dann true zurück, wenn sich auf dem Feld unmmittelbar rechts von Kara ein Baumstumpf befindet.
    **/
   public final boolean treeRight();

   /**
    * Gibt genau dann true zurück, wenn sich vor Kara ein Pilz befindet.
    **/
   public final boolean mushroomFront();

   /**
    * Dreht Kara um 90° nach links (d.h. gegen den Uhrzeigersinn).
    **/
   public final void turnLeft();

   /**
    * Dreht Kara um 90° nach rechts (d.h. im Uhrzeigersinn).
    **/
   public final void turnRight();

   /**
    * Legt ein Kleeblatt auf die Position, an der Kara gerade steht.
    **/
   public final void putLeaf();

   /**
    * Kara nimmt das Kleeblatt, das sich auf seiner aktuellen Position befindet.
    **/
   public final void removeLeaf();

}

public class Key {
   public static final String ArrowUp;
   public static final String ArrowDown;
   public static final String ArrowLeft;
   public static final String ArrowRight;
   public static final String Enter;
   public static final String Space;
   public static final String Shift;
   public static final String Alt;
   public static final String Strg;
   public static final String PageUp;
   public static final String PageDown;
   public static final String Backspace;
   public static final String Escape;
   public static final String Entf;
   public static final String Einf;
   public static final String Ende;
}

public interface KeyListener {
   /**
    * Wird aufgerufen, nachdem eine Taste gedrückt und wieder losgelassen wurde.
    **/
   public void onKeyTyped(String key);

}

/**
 * Das Material verwendet ein nichtphysikalisches Lambertmodell zur Berechnung des Reflexionsgrads. Dadurch können einige
 * Oberflächen (z. B. unbehandeltes Holz oder Stein) gut simuliert werden.
 *     Glänzende Oberflächen mit Glanzlichtern (z. B. lackiertes Holz) können jedoch nicht simuliert werden. MeshLambertMaterial
 * berechnet die Schattierung je Fragment (d.h. ca. je Bildschirmpixel).
 *     Aufgrund der Einfachheit der Reflexions- und Beleuchtungsmodelle ist die Performance bei Verwendung dieses Materials höher
 * als bei PhongMaterial oder StandardMaterial, allerdings auf Kosten einer gewissen grafischen Genauigkeit.
 *     
 **/
public class LambertMaterial3d {
   /**
    * Legt fest, ob das Objekt ungefüllt (nur als Gitter) gezeichnet werden soll.
    **/
   public boolean wireframe;
   /**
    * Erzeugt ein neues LambertMaterial-Objekt
    **/
   public LambertMaterial3d(int color);

   /**
    * Erzeugt ein neues LambertMaterial-Objekt
    **/
   public LambertMaterial3d(String color);

   /**
    * Erzeugt ein neues LambertMaterial-Objekt
    **/
   public LambertMaterial3d(Color color);

   /**
    * Erzeugt ein LambertMaterial-Objekt mit einer Textur, z.B. new LambertMaterial(Texture.earth2k).
    **/
   public LambertMaterial3d(Texture texture);

   /**
    * Erzeugt ein LambertMaterial-Objekt mit einer Textur, z.B. new LambertMaterial(SpriteLibrary.plattforms, 20).
    **/
   public LambertMaterial3d(SpriteLibrary spriteLibrary, int imageIndex);

   /**
    * Farbe, mit der das Objekt selbst leuchtet.
    **/
   public void setEmissive(int color);

   /**
    * Farbe, mit der das Objekt selbst leuchtet.
    **/
   public void setEmissive(String color);

   /**
    * Farbe, mit der das Objekt selbst leuchtet.
    **/
   public void setEmissive(Color color);

   /**
    * Farbe, mit der das Objekt selbst leuchtet.
    **/
   public int getEmissive();

   /**
    * Legt fest, ob das Objekt ungefüllt (nur als Gitter) gezeichnet werden soll.
    **/
   public boolean isWireframe();

   /**
    * Legt fest, ob das Objekt ungefüllt (nur als Gitter) gezeichnet werden soll.
    **/
   public void setWireframe(boolean value);

}

public class Light3d {
   public Material3d material;
   public Light3d();

   public void move(double x, double y, double z);

   public final void move(Vector3 v);

   public void moveTo(double x, double y, double z);

   public final void moveTo(Vector3 p);

   public void destroy();

   public void rotateX(double angleDeg);

   public void rotateY(double angleDeg);

   public void rotateZ(double angleDeg);

   public void setIntensity(double intensity);

   public double getIntensity();

   public void setColor(int color);

   public void setColor(String color);

   public void setColor(Color color);

}

/**
 * Die Klasse Line repräsentiert eine Strecke
 **/
public class Line {
   /**
    * Erstellt eine gerade Strecke vom Punkt (0, 0) zum Punkt (100, 100).
    **/
   public Line();

   /**
    * Erstellt eine gerade Strecke von (x1, y1) nach (x2, y2).
    **/
   public Line(double x1, double y1, double x2, double y2);

   /**
    * Ändert Start- und Endpunkt der Linie.
    **/
   public final void setPoints(double x1, double y1, double x2, double y2);

   /**
    * Erstellt eine Kopie der Linie.
    **/
   public final Line copy();

   /**
    * Wandelt das Objekt in eine Zeichenkette um und liefert diese zurück.
    **/
   public String toString();

}

public class LinkedList<E> {
   /**
    * Erzeugt eine neue, leere LinkedList.
    **/
   public LinkedList();

   /**
    * Gibt ein Iterator-Objekt für dieses Iterable-Objekt zurück.
    **/
   public Iterator<E> iterator();

   /**
    * Führt die angegebene Aktion für jedes Element dieses Iterable-Objekts aus.
    **/
   public void forEach(Consumer<?> action);

   /**
    * Wandelt die Collection in ein Array um und gibt dieses zurück.
    **/
   public Object[] toArray();

   /**
    * Wandelt die Collection in ein Array um und gibt dieses zurück. Als Parameter muss ein Muster-Array übergeben werden, das den Typ
    * des zurückgegebenen Arrays bestimmt.
    **/
   public <T> T[] toArray(T[] a);

   /**
    * Fügt das übergebene Element ans Ende der Liste an.
    **/
   public boolean add(E e);

   /**
    * Fügt alle Elemente der übergebenen Collection ans Ende der Liste an.
    **/
   public boolean addAll(Collection<?> c);

   /**
    * Entleert die Liste. Die Liste ist nach Aufruf dieser Methode leer. Die Elemente der Liste werden dadurch nicht beeinträchtigt.
    **/
   public void clear();

   /**
    * Gibt genau dann true zurück, wenn die Liste das angegebene Element enthält.
    **/
   public boolean contains(E Element);

   /**
    * Gibt genau dann true zurück, wenn die Liste alle Elemente der übergebenen Collection enthält.
    **/
   public boolean containsAll(Collection<?> c);

   /**
    * Gibt genau dann true zurück, wenn die Liste leer ist, d.h. keine Elemente enthält.
    **/
   public boolean isEmpty();

   /**
    * Falls die Liste das übergebene Element enthält, entnimmt diese Methode der Liste das erste solche Element. Die Methode gibt
    * genau dann true zurück, wenn die Liste das Element enthalten hat.
    **/
   public boolean remove(E element);

   /**
    * Entnimnt der Liste alle Vorkommen aller Elemente der übergebenen Collection.
    **/
   public boolean removeAll(Collection<?> c);

   /**
    * Gibt die Anzahl der in der Liste enthaltenen Elemente zurück. Ist ein Element mehrfach enthalten, so wird es dabei mehrfach
    * gezählt.
    **/
   public int size();

   /**
    * Entfernt das Element am Kopf der Liste und gibt es zurück. Führt zum Fehler, wenn die Liste leer ist.
    **/
   public E remove();

   /**
    * Entfernt das Element am Kopf der Liste und gibt es zurück. Gibt null zurück, wenn die Liste leer ist.
    **/
   public E poll();

   /**
    * Gibt das Element am Kopf der Liste zurück, entfernt es aber nicht. Gib null zurück, wenn die Liste leer ist.
    **/
   public E peek();

   /**
    * Fügt ein Element hinten an die Liste an. Gibt true zurück, wenn das Element eingefügt werden konnte, ansonsten false.
    **/
   public boolean offer(E element);

   /**
    * Löscht das erste Vorkommen des Objekts. Gibt true zurück, wenn die Liste dadurch verändert wurde.
    **/
   public boolean removeFirstOccurrence(E element);

   /**
    * Löscht das letzte Vorkommen des Objekts. Gibt true zurück, wenn die Liste dadurch verändert wurde.
    **/
   public boolean removeLastOccurrence(E element);

   /**
    * Fügt das Element am Anfang der Liste ein.
    **/
   public void addFirst(E element);

   /**
    * Fügt das Element am Ende der Liste ein.
    **/
   public void addLast(E element);

   /**
    * Entfernt das Element am Anfang der Liste und gibt es zurück. Führt zum Fehler, wenn die Liste leer ist.
    **/
   public E removeFirst();

   /**
    * Entfernt das Element am Ende der Liste und gibt es zurück. Führt zum Fehler, wenn die Liste leer ist.
    **/
   public E removeLast();

   /**
    * Gibt das Element am Anfang der Liste zurück, entfernt es aber nicht. Gib null zurück, wenn die Liste leer ist.
    **/
   public E peekFirst();

   /**
    * Gibt das Element am Ende der Liste zurück, entfernt es aber nicht. Gib null zurück, wenn die Liste leer ist.
    **/
   public E peekLast();

   /**
    * Gibt das Element am Ende der Liste zurück und entfernt es von der Liste. Erzeugt einen Fehler, wenn die Liste leer ist.
    **/
   public E pop();

   /**
    * Fügt das Element am Ende der Liste hinzu.
    **/
   public void push(E element);

   /**
    * Gibt einen Iterator über die Elemente dieser Collection zurück, der die Liste in umgekehrter Reihenfolge (Ende -> Anfang)
    * durchläuft.
    **/
   public Iterator<E> descendingIterator();

   /**
    * Fügt das angegebene Element an der angegebenen Position in die Liste ein. Alle nachfolgendne Elemente werden um eine Position
    * nach hinten verschoben.
    **/
   public boolean add(int index, E element);

   /**
    * Gibt das Element an der angegebenen Position zurück.
    *  Das erste Element der Liste hat Position 0.
    **/
   public E get(int index);

   /**
    * Gibt den Index des angegebenen Elements in der Liste zurück. Falls das Element nicht in der Liste enthalten ist, wird -1
    * zurückgegeben.
    * Tipp: Das erste Element der Liste hat Index 0.
    **/
   public int indexOf(E Element);

   /**
    * Entfernt das Element mit dem angegebenen Index aus der Liste.
    * Tipp: Das erste Element der Liste hat Index 0.
    **/
   public E remove(int index);

   /**
    * Setzt das übergebene Element an der angegebenen Position in die Liste anstatt des bisher dort vorhandenen.
    **/
   public E set(int index, E Element);

   /**
    * Sortiert die Liste anhand des übergebenen Comparator-Objekts.
    **/
   public void sort(Comparator<?> comparator);

   /**
    * Wandelt das Objekt in eine Zeichenkette um und liefert diese zurück.
    **/
   public String toString();

}

public interface List<E> {
   /**
    * Fügt das angegebene Element an der angegebenen Position in die Liste ein. Alle nachfolgendne Elemente werden um eine Position
    * nach hinten verschoben.
    **/
   public boolean add(int index, E element);

   /**
    * Fügt alle Elemente der übergebenen Collection an der angegebenen Position in die Liste ein. Alle nachfolgendne Elemente werden
    * entsprechend nach hinten verschoben.
    **/
   public boolean addAll(int index, Collection<?> c);

   /**
    * Gibt das Element an der angegebenen Position zurück.
    *  Das erste Element der Liste hat Position 0.
    **/
   public E get(int index);

   /**
    * Gibt den Index des angegebenen Elements in der Liste zurück. Falls das Element nicht in der Liste enthalten ist, wird -1
    * zurückgegeben.
    * Tipp: Das erste Element der Liste hat Index 0.
    **/
   public int indexOf(E element);

   /**
    * Entfernt das Element mit dem angegebenen Index aus der Liste.
    * Tipp: Das erste Element der Liste hat Index 0.
    **/
   public E remove(int index);

   /**
    * Setzt das übergebene Element an der angegebenen Position in die Liste anstatt des bisher dort vorhandenen.
    **/
   public E set(int index, E element);

   /**
    * Sortiert die Liste anhand des übergebenen Comparator-Objekts.
    **/
   public void sort(Comparator<?> comparator);

}

/**
 * Ein LocalDate-Objekt speichert einen Zeitpunkt (Datum und Uhrzeit) und kann auch die Systemzeit auslesen.
 **/
public class LocalDateTime {
   /**
    * Holt den aktuellen Zeitpunkt von der Systemuhr des Rechners und gibt ihn als LocalDateTime-Objekt zurück.
    **/
   public LocalDateTime();

   /**
    * Holt den aktuellen Zeitpunkt von der Systemuhr des Rechners und gibt ihn als LocalDateTime-Objekt zurück.
    **/
   public static LocalDateTime now();

   /**
    * Gibt ein LocalDateTime-Objekt zurück, das den durch year, month (1 - 12), dayOfMonth, hour, minute, second beschriebenen
    * Zeitpunkt repräsentiert.
    **/
   public static LocalDateTime of(int year, int month, int dayOfMonth, int hour, int minute, int second);

   /**
    * Gibt ein neues LocalDateTime-Objekt zurück, das einen Zeitpunkt repräsentiert, der um die übergebene Anzahl von Tagen später
    * liegt.
    **/
   public LocalDateTime plusDays(int days);

   /**
    * Gibt ein neues LocalDateTime-Objekt zurück, das einen Zeitpunkt repräsentiert, der um die übergebene Anzahl von Tagen früher
    * liegt.
    **/
   public LocalDateTime minusDays(int days);

   /**
    * Gibt zurück, wie viele Tage (gerundet) zwischen den beiden Zeitpunkten liegen.
    **/
   public int until(LocalDateTime object);

   /**
    * Jahr
    **/
   public int getYear();

   /**
    * Gibt den Monat als Zahl zurück (Januar == 1, Februar == 2, ..., Dezember == 12).
    **/
   public int getMonth();

   /**
    * Gibt den Tag innerhalb des Monats zurück (Zahl von 1 bis 31).
    **/
   public int getDayOfMonth();

   /**
    * Stunde
    **/
   public int getHour();

   /**
    * Minute
    **/
   public int getMinute();

   /**
    * Sekunde
    **/
   public int getSecond();

   /**
    * Vergleicht das Objekt mit dem übergebenen Objekt. Liefert eine negative Zahl zurück, wenn das Objekt 'kleiner' ist als das
    * übergebene, eine positive, falls es größer ist und 0, wenn beide Objekte gleich sind.
    **/
   public int compareTo(LocalDateTime object);

   /**
    * Wandelt das Objekt in eine Zeichenkette um und liefert diese zurück.
    **/
   public String toString();

}

public class Long {
   public static final int MAX_VALUE;
   public static final int MIN_VALUE;
   public Long(long d);

   public final double doubleValue();

   public final float floatValue();

   public final int intValue();

   public final long longValue();

   public int compareTo(Long anotherLong);

   public long parseLong(String s);

   public long parseLong(String sr, int radix);

   public static Long valueOf(long i);

   public static Long valueOf(String s);

   public static Long valueOf(String s, int radix);

}

/**
 * Eine Map ist ein Schlüssel-Wert-Speicher (key-value store). Eine Map kann keinen Schlüssel mehrfach enthalten.
 **/
public interface Map<K, V> {
   /**
    * Gibt die Anzahl der Schlüssel-Wert-Paare der Map zurück.
    **/
   public int size();

   /**
    * Gibt genau dann true zurück, wenn die Map keine Schlüssel-Wert-Paare enthält.
    **/
   public boolean isEmpty();

   /**
    * Gibt genau dann true zurück, wenn die Map zum Schlüssel key einen Wert enthält.
    **/
   public boolean containsKey(K key);

   /**
    * Gibt genau dann true zurück, wenn die Map den Wert enthält.
    **/
   public boolean containsValue(V value);

   /**
    * Gibt den Wert zum Schlüssel key zurück. Gibt null zurück, falls die Map zum Schlüssel key keinen Wert enthält.
    **/
   public V get(K key);

   /**
    * Speichert das key-value pair in der Map. Falls zum key vorher schon ein Value gespeichert war, wird dieser zurückgegeben. In der
    * Map wird er dann durch den neuen Value überschrieben. Falls es zum key noch keinen value in der Map gab, wird null
    * zurückgegeben.
    **/
   public V put(K key, V value);

   /**
    * Entfernt alle Schlüssel-Wert-Paare aus der Map.
    **/
   public void clear();

   /**
    * Führt die angegebene Aktion für jedes Schlüssel-Wert-Paar dieser Map aus.
    **/
   public void forEach(BiConsumer<?, ?> action);

   /**
    * Gibt eine Collection zurück, die alle Werte der Map enthält (ggf. auch mehrfach).
    **/
   public Collection<V> values();

   /**
    * Gibt ein Set zurück, das alle Schlüssel dieser Map enthält.
    **/
   public Set<K> keySet();

   /**
    * Entfernt das Mapping für den gegebenen Schlüssel (falls vorhanden). Gibt ggf. den zu diesem Schlüssel gespeicherten Wert zurück
    * oder null, falls zum Schlüssel kein Wert gespeichert war.
    **/
   public V remove(K key);

   /**
    * Entfernt das Mapping für den gegebenen Schlüssel (falls vorhanden). Gibt ggf. den zu diesem Schlüssel gespeicherten Wert zurück
    * oder null, falls zum Schlüssel kein Wert gespeichert war.
    **/
   public boolean remove(K key, V value);

}

/**
 * Oberklasse aller Material3d-Klassen
 **/
public class Material3d {
   /**
    * Setzt die Farbe des Materials. Zum Setzen der Durchsichtigkeit (Alpha-Value) benutze setAlpha.
    **/
   public Material3d setColor(Color color);

   /**
    * Setzt die Farbe des Materials. Zum Setzen der Durchsichtigkeit (Alpha-Value) benutze setAlpha.
    **/
   public Material3d setColor(int color);

   /**
    * Setzt die Farbe des Materials. Zum Setzen der Durchsichtigkeit (Alpha-Value) benutze setAlpha.
    **/
   public Material3d setColor(String color);

   /**
    * Gibt die Farbe als int-Wert zurück.
    **/
   public int getColor();

   /**
    * Gibt true zurück, falls transparente Teile des Körpers auch transparent gezeichnet werden sollen.
    **/
   public boolean isTransparent();

   /**
    * Falls der Wert true ist, werden transparente Teile des 3d-Körpers auch transparent gezeichnet. Nachteil ist eine etwas geringere
    * Performance.
    **/
   public Material3d setTransparent(boolean value);

   /**
    * Wenn flatShading == true ist, wird der Farbwert nur jeweils pro gerendertem Dreieck berechnet, nicht per Fragment (Pixel). Das
    * hat eine etwas höhere Performance zur Folge.
    **/
   public boolean isFlatShading();

   /**
    * Wenn flatShading == true ist, wird der Farbwert nur jeweils pro gerendertem Dreieck berechnet, nicht per Fragment (Pixel). Das
    * hat eine etwas höhere Performance zur Folge.
    **/
   public Material3d setFlatShading(boolean value);

   /**
    * Der Alphawert (0 ... 1) bestimmt die Durchsichtigkeit des Objekts. Tipp: Damit die Durchsichtigkeit sichtbar wird, musst Du noch
    * setTransparent(true) aufrufen.
    **/
   public Material3d setAlpha(double value);

   /**
    * Der Alphawert (0 ... 1) bestimmt die Durchsichtigkeit des Objekts. Tipp: Damit die Durchsichtigkeit sichtbar wird, musst Du noch
    * setTransparent(true) aufrufen.
    **/
   public double getAlpha(double value);

   /**
    * Legt fest, ob das Objekt ungefüllt (nur als Gitter) gezeichnet werden soll.
    **/
   public Material3d setWireframe(boolean value);

   /**
    * Legt fest, ob das Objekt ungefüllt (nur als Gitter) gezeichnet werden soll.
    **/
   public boolean isWireframe();

}

public class Math {
   /**
    * Die Zahl Pi (3.14159...) in double-Genauigkeit (ca. 15 Nachkommastellen)
    **/
   public static final double PI;
   /**
    * Die Zahl e (2.718281828459045...) in double-Genauigkeit (ca. 15 Nachkommastellen)
    **/
   public static final double E;
   /**
    * Betrag der übergebenen Zahl
    **/
   public static int abs(int a);

   /**
    * Betrag der übergebenen Zahl
    **/
   public static long abs(long a);

   /**
    * Betrag der übergebenen Zahl
    **/
   public static float abs(float a);

   /**
    * Betrag der übergebenen Zahl
    **/
   public static double abs(double a);

   /**
    * Sinus des übergebenen Winkels (im Bogenmaß)
    **/
   public static double sin(double angleInRadians);

   /**
    * Cosinus des übergebenen Winkels (im Bogenmaß)
    **/
   public static double cos(double angleInRadians);

   /**
    * Tangens des übergebenen Winkels (im Bogenmaß)
    **/
   public static double tan(double angleInRadians);

   /**
    * Arcussinus der übergebenen Zahl
    **/
   public static double asin(double angleInRadians);

   /**
    * Arcuscosinus der übergebenen Zahl
    **/
   public static double acos(double angleInRadians);

   /**
    * Arcustangens der übergebenen Zahl
    **/
   public static double atan(double angleInRadians);

   /**
    * Gibt den Winkel (im Bogenmaß) von der positiven x-Achse aus zum Vektor (x/y) zurück.
    **/
   public static double atan2(double y, double x);

   /**
    * Rundet die übergebene Zahl auf eine ganze Zahl. Ab '...,5' wird aufgerundet.
    **/
   public static int round(double value);

   /**
    * Rundet die übergebene Zahl auf eine ganze Zahl ab, d.h. aus 45.9 wird beispielsweise 45.
    **/
   public static int floor(double value);

   /**
    * Rundet die übergebene Zahl auf eine ganze Zahl auf, d.h. aus 45.1 wird beispielsweise 46.
    **/
   public static int ceil(double value);

   /**
    * Vorzeichen einer Zahl, d.h. -1 falls die Zahl negativ ist, +1 falls die Zahl positiv ist und 0, falls die Zahl 0 ist.
    **/
   public static int signum(double value);

   /**
    * Quadratwurzel der Zahl
    **/
   public static double sqrt(double a);

   /**
    * Zufallszahl aus dem Bereich [0; 1[
    **/
   public static double random();

   /**
    * Potenz 'Basis hoch Exponent'
    **/
   public static double pow(double basis, double exponent);

   /**
    * Wandelt den übergebenen Winkel vom Bogenmaß ins Gradmaß um, d.h. berechnet angle/pi * 180.
    **/
   public static double toDegrees(double angleInRad);

   /**
    * Wandelt den übergebenen Winkel vom Gradmaß ins Bogenmaß um, d.h. berechnet angle/180 * pi.
    **/
   public static double toRadians(double angleInDegrees);

   /**
    * Berechnet 'e hoch zahl'
    **/
   public static double exp(double value);

   /**
    * Berechnet den natürlichen Logarithmus der Zahl
    **/
   public static double log(double value);

   /**
    * Berechnet den Logarithmus der Zahl zur Basis 10.
    **/
   public static double log10(double value);

   /**
    * Gibt die größere der beiden Zahlen zurück.
    **/
   public static int max(int a, int b);

   /**
    * Gibt die größere der beiden Zahlen zurück.
    **/
   public static long max(long a, long b);

   /**
    * Gibt die größere der beiden Zahlen zurück.
    **/
   public static float max(float a, float b);

   /**
    * Gibt die größere der beiden Zahlen zurück.
    **/
   public static double max(double a, double b);

   /**
    * Gibt die kleinere der beiden Zahlen zurück.
    **/
   public static int min(int a, int b);

   /**
    * Gibt die kleinere der beiden Zahlen zurück.
    **/
   public static long min(long a, long b);

   /**
    * Gibt die kleinere der beiden Zahlen zurück.
    **/
   public static float min(float a, float b);

   /**
    * Gibt die kleinere der beiden Zahlen zurück.
    **/
   public static double min(double a, double b);

}

/**
 * Klasse mit mathematischen Hilfsfunktionen als statische Methoden
 **/
public class MathTools {
   /**
    * Zu einem gegebenen Kreis werden die Punkte berechnet, die auf den Seiten eines gegebenen Polygons liegen.
    **/
   public static Vector2[] intersectCircleWithPolygon(double mx, double my, double r, Vector2[] polygon);

   /**
    * Berechnet den Schnittpunkt der Strecken [p0, p1] und [p2, p3]. Gibt null zurück, wenn sich die Strecken nicht schneiden oder
    * wenn sie parallel sind und teilweise aufeinander liegen.
    **/
   public static Vector2 intersectLineSegments(Vector2 p0, Vector2 p1, Vector2 p2, Vector2 p3);

   /**
    * Gibt genau dann true zurück, wenn das Polygon den Punkt enthält.
    **/
   public static boolean polygonContainsPoint(Vector2[] polygonPoints, Vector2 p);

   /**
    * Berechnet den Abstand des Punktes P zur Gerade AB.
    **/
   public static double distancePointToLine(Vector2 p, Vector2 a, Vector2 b);

   /**
    * Berechnet den Abstand des Punktes P zur Gerade AB.
    **/
   public static double distancePointToLineSegment(Vector2 p, Vector2 a, Vector2 b);

}

/**
 * Eine 4x4-Matrix, die insbesondere verwendet werden kann, um eine affine Abbildung im R³ zu beschreiben und räumliche Körper zu
 * transformieren.
 **/
public class Matrix4 {
   /**
    * Erstellt eine 4x4-Einheitsmatrix, d.h. eine Matrix mit 1-sen in der Diagonalen und ansonsten 0-en.
    **/
   public Matrix4();

   /**
    * Erstellt eine 4x4-Matrix mit den gegebenen Komponenten (zeilenweise).
    **/
   public Matrix4(double n11, double n12, double n13, double n14, double n21, double n22, double n23, double n24, double n31, double n32, double n33, double n34, double n41, double n42, double n43, double n44);

   /**
    * Erstellt eine Kopie der übergebenen Matrix.
    **/
   public Matrix4(Matrix4 otherMatrix);

   /**
    * Ersetzt diese Matrix durch eine, die eine Rotation um die X-Achse mit gegebenem Winkel (in Grad) repräsentiert.
    **/
   public Matrix4 makeRotationX(double angleInDegrees);

   /**
    * Ersetzt diese Matrix durch eine, die eine Rotation um die Y-Achse mit gegebenem Winkel (in Grad) repräsentiert.
    **/
   public Matrix4 makeRotationY(double angleInDegrees);

   /**
    * Ersetzt diese Matrix durch eine, die eine Rotation um die Z-Achse mit gegebenem Winkel (in Grad) repräsentiert.
    **/
   public Matrix4 makeRotationZ(double angleInDegrees);

   /**
    * Ersetzt diese Matrix durch eine, die eine Rotation um die gegebene mit gegebenem Winkel (in Grad) repräsentiert.
    **/
   public Matrix4 makeRotationAxis(Vector3 axis);

   /**
    * Ersetzt diese Matrix durch eine, die die Streckung um die gegebenen Faktoren in x-, y- und z-Richtung repräsentiert.
    **/
   public Matrix4 makeScale(double x, double y, double z);

   /**
    * Ersetzt diese Matrix durch eine, die die Verschiebung um den gegebenen Vektor repräsentiert.
    **/
   public Matrix4 makeTranslation(Vector3 v);

   /**
    * Ersetzt diese Matrix durch eine, die die Verschiebung um den gegebenen Vektor repräsentiert.
    **/
   public Matrix4 makeTranslation(double x, double y, double z);

   /**
    * Multipliziert die Matrix mit dem gegebenen Faktor (Skalarmultiplikation).
    **/
   public Matrix4 multiplyScalar(double factor);

   /**
    * Invertiert diese Matrix. Is sie nicht invertierbar, so wird sie auf die Nullmatrix gesetzt.
    **/
   public Matrix4 invert();

   /**
    * Berechnet die Determinante dieser Matrix.
    **/
   public double determinant();

   /**
    * Erzeugt eine Kopie dieser Matrix.
    **/
   public Matrix4 clone();

   /**
    * Kopiert die gegebene Matrix in diese hinein.
    **/
   public Matrix4 copyFropm(Matrix4 m);

   /**
    * Multipliziert diese Matrix von rechts mit der gegebene Matrix und schreibt das Ergebnis in diese Matrix.
    **/
   public Matrix4 multiply(Matrix4 m);

   /**
    * Multipliziert diese Matrix von links mit der gegebene Matrix und schreibt das Ergebnis in diese Matrix.
    **/
   public Matrix4 premultiply(Matrix4 m);

}

/**
 * Basisklasse für alle 3d-Meshes, d.h. Objekte, die aus Dreicken bestehen.
 **/
public class Mesh3d {
   public Mesh3d();

   public Material3d getMaterial();

   public void setMaterial(Material3d material);

   public void move(double x, double y, double z);

   public final void move(Vector3 v);

   public void moveTo(double x, double y, double z);

   public final void moveTo(Vector3 p);

   public void rotateX(double angleDeg);

   public void rotateY(double angleDeg);

   public void rotateZ(double angleDeg);

   public final void scaleX(double scale);

   public final void scaleY(double scale);

   public final void scaleZ(double scale);

   public final void scale(Vector3 v);

   public final void scale(double d);

   public final void applyMatrix4(Matrix4 matrix);

   public final void enableFrontBackSide(boolean frontSideVisible, boolean backSideVisible);

   public final void repeatTexture(int repeatX, int repeatY);

   public final void renderTransparent(boolean transparent);

   public void destroy();

}

public class MethodOfDestroyedObjectCalledException {
}

/**
 * Interface mit Methoden, die aufgerufen werden, wenn Maus-Ereignisse eintreten. Ein Objekt, das dieses Interface implementiert
 * muss zuvor aber mit world.addMouseListener() registriert werden, wobei world das aktuelle World-Objekt ist.
 **/
public interface MouseListener {
   /**
    * Wird aufgerufen, wenn eine Maustaste über dem Grafikbereich losgelassen wird.
    **/
   public void onMouseUp(double x, double y, int button);

   /**
    * Wird aufgerufen, wenn eine Maustaste über dem Grafikbereich gedrückt wird.
    **/
   public void onMouseDown(double x, double y, int button);

   /**
    * Wird aufgerufen, wenn der Mauszeiger über dem Grafikbereich bewegt wird.
    **/
   public void onMouseMove(double x, double y);

   /**
    * Wird aufgerufen, wenn der Mauszeiger in den Grafikbereich hineinbewegt wird.
    **/
   public void onMouseEnter(double x, double y);

   /**
    * Wird aufgerufen, wenn der Mauszeiger den Grafikbereich verlässt.
    **/
   public void onMouseLeave(double x, double y);

}

public class NullPointerException {
}

public class Number {
   public byte byteValue();

   public short shortValue();

   public double doubleValue();

   public float floatValue();

   public int intValue();

   public long longValue();

   public String toString();

}

public class Object {
   public Object();

   /**
    * Wandelt das Objekt in eine Zeichenkette um und liefert diese zurück.
    **/
   public String toString();

   /**
    * Gibt genau dann true zurück, wenn das Objekt und das übergebene Objekt 'gleich' sind.
    **/
   public boolean equals(Object otherObject);

   /**
    * Bewirkt, dass der aktuelle Thread wartet bis in einem anderen Thread die Methode notify() oder notifyAll() dieses Objekts
    * aufgerufen wird.
    **/
   public final void wait();

   /**
    * Bewirkt, dass der aktuelle Thread wartet bis in einem anderen Thread die Methode notify() oder notifyAll() dieses Objekts
    * aufgerufen wird oder das übergebene Timeout (in ms) abläuft.
    **/
   public final void wait(long milliseconds);

   /**
    * Weckt einen der Threads auf, der auf den Monitor dieses Objektes wartet.
    **/
   public final void notify();

   /**
    * Weckt alle Threads auf, die auf den Monitor dieses Objektes warten.
    **/
   public final void notifyAll();

   /**
    * Gibt das Class-Objekt zurück, das der Klasse dieses Objekts zugeordnet ist.
    **/
   public final Class<?> getClass();

}

/**
 * Basisklasse für alle 3d-Objekte
 **/
public class Object3d {
   public Object3d();

   public void move(double x, double y, double z);

   public final void move(Vector3 v);

   public void moveTo(double x, double y, double z);

   public final void moveTo(Vector3 p);

   public void lookAt(double xTarget, double yTarget, double zTarget, Vector3 up);

   public void lookAt(Object3d target, Vector3 up);

   public void rotateX(double angleDeg);

   public void rotateY(double angleDeg);

   public void rotateZ(double angleDeg);

   public void scaleX(double angleDeg);

   public void scaleY(double angleDeg);

   public void scaleZ(double angleDeg);

   public void scale(Vector3 v);

   public void scale(double d);

   public double getX();

   public double getY();

   public double getZ();

   /**
    * Gibt das aktuelle World3d-Objekt zurück.
    **/
   public final World3d getWorld3d();

   public void destroy();

}

/**
 * Ein Container-Objekt das einen Nicht-null-Wert enthalten kann oder auch nicht. Falls es eine Wert enthält liefert isPresent()
 * true und get() den Wert.
 **/
public class Optional<T> {
   /**
    * Gibt ein leeres Optional-Objekt zurück.
    **/
   public static Optional<T> empty();

   /**
    * Gibt genau dann true zurück, wenn beide Optional-Objekte leer sind oder wenn die enthaltenen Objekte gleich sind, ausgehend von
    * deren equals-Funktion.
    **/
   public boolean equals(Object o);

   /**
    * Gibt genau dann zurück, wenn im Optional-Objekt kein Wert enthalten ist.
    **/
   public boolean isEmpty();

   /**
    * Wenn das Optional-Objekt einen Wert enthält liefert diese Methode Optional.of(f(Wert)) zurück, ansonsten ein leeres
    * Optional-Objekt.
    **/
   public <U> Optional<U> map(Function<T, U> f);

   /**
    * Wenn das Optional-Objekt einen Wert enthält liefert diese Methode f(Wert) zurück, ansonsten ein leeres Optional-Objekt.
    **/
   public <U> Optional<U> flatMap(Function<T, Optional<U>> f);

   /**
    * Gibt ein Optional-Objekt zurück das den gegebenen (von null verschiedenen) Wert enthält.
    **/
   public static <T> Optional<T> of(T t);

   /**
    * Wenn das Optional-Objekt einen Wert enthält liefert die Methode diesen zurück, ansonsten den übergebenen Wert t.
    **/
   public T orElse(T t);

   /**
    * Wenn das Optional-Objekt einen Wert enthält wird damit die übergebene Aktion ausgeführt, ansonsten wird nichts gemacht.
    **/
   public void ifPresent(Consumer<?> c);

   /**
    * Gibt eine nichtleere String-Darstellung des Optional-Objekts zurück, passend zum Debuggen.
    **/
   public String toString();

}

public class OrthographicCamera3d {
   public OrthographicCamera3d(double left, double right, double top, double bottom, double near, double far);

}

/**
 * Wenn Du Deine Klasse von PApplet ableitest (class Test extends PApplet{...}), kannst Du auf diese Weise ein Processing-Applet
 * erstellen (siehe https://processing.org), indem Du ihre Methoden draw(), mousePressed(), usw. überschreibst und mit Inhalt
 * füllst. Du startest das Applet, indem Du ein Objekt Deiner Klasse instanzierst und davon die main-Methode aufrufst: new
 * Test().main();
 **/
public class PApplet {
   /**
    * aktuelle x-Koordinate des Mauszeigers
    **/
   public int mouseX;
   /**
    * aktuelle y-Koordinate des Mauszeigers
    **/
   public int mouseY;
   /**
    * x-Koordinate des Mauszeigers im vorherigen Frame
    **/
   public int pMouseX;
   /**
    * y-Koordinate des Mauszeigers im vorherigen Frame
    **/
   public int pMouseY;
   /**
    * Zuletzt gedrückte Maustaste, kann die Werte LEFT, RIGHT und CENTER annehmen.
    **/
   public int mouseButton;
   /**
    * Letzte gedrückte Taste
    **/
   public String key;
   /**
    * links
    **/
   public int LEFT;
   /**
    * Mitte
    **/
   public int CENTER;
   /**
    * rechts
    **/
   public int RIGHT;
   /**
    * obenbündig
    **/
   public int TOP;
   /**
    * bündig auf der Grundlinie
    **/
   public int BASELINE;
   /**
    * untenbündig
    **/
   public int BOTTOM;
   /**
    * Modus zum Zeichnen von Rechtecken.
    **/
   public int CORNER;
   /**
    * Modus zum Zeichnen von Rechtecken.
    **/
   public int CORNERS;
   /**
    * Modus zum Zeichnen von Rechtecken.
    **/
   public int RADIUS;
   /**
    * zeichne nachfolgend Einzelpunkte
    **/
   public int POINTS;
   /**
    * zeichne nachfolgend einzelne Linien
    **/
   public int LINES;
   /**
    * zeichne nachfolgend einzelne Dreiecke
    **/
   public int TRIANGLES;
   /**
    * zeichne nachfolgend einen Triangle-Strip
    **/
   public int TRIANGLE_STRIP;
   /**
    * zeichne nachfolgend einen Triangle-Fan
    **/
   public int TRIANGLE_FAN;
   /**
    * zeichne nachfolgend Vierecke
    **/
   public String QUADS;
   /**
    * zeichne nachfolgend einen Quad-Strip
    **/
   public String QUAD_STRIP;
   /**
    * zeichne nachfolgend ein TESS - geht nur bei createCanvas(width, height, WEBGL)
    **/
   public String TESS;
   /**
    * endShape(CLOSE) schließt den Linienzug
    **/
   public String CLOSE;
   /**
    * angleMode(DEGREES) sorgt dafür, dass nachfolgende Winkelangaben in Grad interpretiert werden.
    **/
   public String DEGREES;
   /**
    * angleMode(RADIANS) sorgt dafür, dass nachfolgende Winkelangaben im Bogenmaß interpretiert werden.
    **/
   public String RADIANS;
   /**
    * WebGL-Renderer zur 3D-Ausgabe
    **/
   public String WEBGL;
   /**
    * Renderer zur zweidimensionalen Ausgabe
    **/
   public String P2D;
   /**
    * Color-Mode RGB (rot, grün, blau)
    **/
   public String RGB;
   /**
    * Color-Mode HSL
    **/
   public String HSL;
   /**
    * Color-Mode HSB
    **/
   public String HSB;
   /**
    * PI = 3.1415...
    **/
   public String PI;
   /**
    * PI/4
    **/
   public String QUARTER_PI;
   /**
    * 2*PI
    **/
   public String TWO_PI;
   /**
    * 2*PI
    **/
   public String TAU;
   /**
    * Legt eine neues Processing-Applet an.
    **/
   public PApplet();

   /**
    * Rufen Sie die Methode main() auf, um das Processing-Applet zu starten.
    **/
   public void main();

   /**
    * Startet nach noLoop() die Renderer-Loop wieder neu, so dass draw() wieder periodisch aufgerufen wird.
    **/
   public void loop();

   /**
    * Stoppt die Render-Loop, so dass draw() nicht mehr aufgerufen wird. Kann mit loop() wieder gestartet werden.
    **/
   public void noLoop();

   /**
    * Definiert die Abmessungen des Processing-Ausgabebereichs in Pixeln.
    **/
   public void size(int width, int height);

   /**
    * Definiert die Abmessungen des Processing-Ausgabebereichs in Pixeln.
    **/
   public void createCanvas(int width, int height);

   /**
    * Definiert die Abmessungen des Processing-Ausgabebereichs in Pixeln.
    **/
   public void createCanvas(int width, int height, String renderer);

   /**
    * Diese Methode wird nach Aufruf von main() genau ein Mal aufgerufen.
    **/
   public void setup();

   /**
    * Diese Methode wird nach Aufruf von main() genau ein Mal aufgerufen.
    **/
   public void settings();

   /**
    * Diese Methode wird nach Aufruf von main() genau ein Mal aufgerufen.
    **/
   public void preload();

   /**
    * Diese Methode wird 60-mal pro Sekunde aufgerufen. Ihr Zweck ist es, die Grafikausgabe zu zeichnen.
    **/
   public void draw();

   /**
    * Die mousePressed-Methode wird immer dann aufgerufen, wenn gerade eine Maustaste heruntergedrückt wurde. Die aktuellen
    * Koordinaten des Mauszeigers liegen in den Attributen mouseX und mouseY vor, die gerade heruntergedrückte Maustaste kann dem
    * Attribut mouseButton entnommen werden.
    **/
   public void mousePressed();

   /**
    * Die mouseReleased-Methode wird immer dann aufgerufen, wenn gerade eine Maustaste losgelassen wurde. Die aktuellen Koordinaten
    * des Mauszeigers liegen in den Attributen mouseX und mouseY vor, die gerade heruntergedrückte Maustaste kann dem Attribut
    * mouseButton entnommen werden.
    **/
   public void mouseReleased();

   /**
    * Die mouseClicked-Methode wird immer dann aufgerufen, wenn gerade eine Maustaste auf dem Zeichenbereich gedrückt und anschließend
    * losgelassen wurde. Die aktuellen Koordinaten des Mauszeigers liegen in den Attributen mouseX und mouseY vor, die gerade
    * heruntergedrückte Maustaste kann dem Attribut mouseButton entnommen werden.
    **/
   public void mouseClicked();

   /**
    * Die mouseDragged-Methode wird immer dann aufgerufen, wenn eine Maustaste gerade heruntergedrückt ist und die Position des
    * Mauszeigers sich verändert hat. Die aktuellen Koordinaten des Mauszeigers liegen in den Attributen mouseX und mouseY vor, die
    * zuletzt gedrückte Maustaste kann dem Attribut mouseButton entnommen werden.
    **/
   public void mouseDragged();

   /**
    * Die mouseEntered-Methode wird immer dann aufgerufen, wenn der Mauszeiger von außen neu in den Zeichenbereich hineinfährt.
    **/
   public void mouseEntered();

   /**
    * Die mouseExited-Methode wird immer dann aufgerufen, wenn der Mauszeiger den Zeichenbereich gerade verlassen hat.
    **/
   public void mouseExited();

   /**
    * Die mouseMoved-Methode wird immer dann aufgerufen, wenn die Position des Mauszeigers sich verändert hat. Die aktuellen
    * Koordinaten des Mauszeigers liegen in den Attributen mouseX und mouseY vor, die zuletzt gedrückte Maustaste kann dem Attribut
    * mouseButton entnommen werden.
    **/
   public void mouseMoved();

   /**
    * Die keyPressed-Methode wird immer dann aufgerufen, wenn eine Taste gerade heruntergedrückt wurde. Informationen zur Taste können
    * den Attributen key (String) und keyCode (int) entnommen werden.
    **/
   public void keyPressed();

   /**
    * Die keyReleased-Methode wird immer dann aufgerufen, wenn eine Taste gerade losgelassen wurde. Informationen zur Taste können den
    * Attributen key (String) und keyCode (int) entnommen werden.
    **/
   public void keyReleased();

   /**
    * Löscht die Zeichenfläche.
    **/
   public final void clear();

   /**
    * Übermalt die komplette Zeichenfläche mit der übergebenen Farbe.
    **/
   public final void background(double rgb);

   /**
    * Übermalt die komplette Zeichenfläche mit der übergebenen Farbe. Übergeben wird eine Zeichenkette der Form 'rgb(0,0,255)' oder
    * 'rgb(0%, 0%, 100%)' oder 'rgba(0, 0, 255, 1)' oder 'rgba(0%, 0%, 100%, 1)' und all diese Kombinationen statt rgb auch mit hsl
    * und hsb.
    **/
   public final String background(String colorAsString);

   /**
    * Übermalt die komplette Zeichenfläche mit der übergebenen Farbe. v1, v2 und v3 sind - abhängig vom aktuellen color mode - rot,
    * grün und blauwert oder Farbe, Sättigung und Helligkeit
    **/
   public final void background(double v1, double v2, double v3);

   /**
    * Setzt die Füllfarbe.
    **/
   public final void fill(int rgb);

   /**
    * Setzt die Füllfarbe.
    **/
   public final void fill(String rgb);

   /**
    * Setzt die Füllfarbe.
    **/
   public final void fill(int rgb, double alpha);

   /**
    * Setzt die Füllfarbe.
    **/
   public final void fill(double gray);

   /**
    * Setzt die Füllfarbe. v1, v2 und v3 sind - abhängig vom aktuellen color mode - rot, grün und blauwert oder Farbe, Sättigung und
    * Helligkeit
    **/
   public final void fill(double v1, double v2, double v3);

   /**
    * Setzt die Füllfarbe. v1, v2 und v3 sind - abhängig vom aktuellen color mode - rot, grün und blauwert oder Farbe, Sättigung und
    * Helligkeit
    **/
   public final void fill(double v1, double v2, double v3, double alpha);

   /**
    * Die nachfolgend gezeichneten Figuren werden nicht gefüllt.
    **/
   public final void noFill();

   /**
    * Setzt die Linienfarbe.
    **/
   public final void stroke(int rgb);

   /**
    * Setzt die Linienfarbe.
    **/
   public final void stroke(String rgb);

   /**
    * Setzt die Linienfarbe.
    **/
   public final void stroke(int rgb, double alpha);

   /**
    * Setzt die Linienfarbe.
    **/
   public final void stroke(double gray);

   /**
    * Setzt die Linienfarbe. v1, v2 und v3 sind - abhängig vom aktuellen color mode - rot, grün und blauwert oder Farbe, Sättigung und
    * Helligkeit
    **/
   public final void stroke(double v1, double v2, double v3);

   /**
    * Setzt die Linienfarbe. v1, v2 und v3 sind - abhängig vom aktuellen color mode - rot, grün und blauwert oder Farbe, Sättigung und
    * Helligkeit
    **/
   public final void stroke(double v1, double v2, double v3, double alpha);

   /**
    * Setzt die Linienbreite.
    **/
   public final void strokeWeight(double weight);

   /**
    * Die nachfolgend gezeichneten Figuren werden ohne Rand gezeichnet.
    **/
   public final void noStroke();

   /**
    * Gibt den Grauton als String-kodierte Farbe zurück.
    **/
   public final String color(double gray);

   /**
    * Gibt die Farbe zurück. Übergeben kann eine Zeichenkette der Form 'rgb(0,0,255)' oder 'rgb(0%, 0%, 100%)' oder 'rgba(0, 0, 255,
    * 1)' oder 'rgba(0%, 0%, 100%, 1)' und all diese Kombinationen statt rgb auch mit hsl und hsb.
    **/
   public final String color(String colorAsString);

   /**
    * Gibt den Grauton als String-kodierte Farbe zurück.
    **/
   public final String color(double gray, double alpha);

   /**
    * Gibt die aus v1, v2, v3 gebildete Farbe String-kodiert zurück.
    **/
   public final String color(double v1, double v2, double v3);

   /**
    * Gibt die aus v1, v2, v3 und alpha gebildete Farbe String-kodiert zurück.
    **/
   public final String color(double v1, double v2, double v3, double alpha);

   /**
    * Gibt eine Zwischenfarbe zwischen colorA und colorB zurück. t == 0 bedeutet: colorA, t == 1 bedeutet: colorB, t == 0.5 bedeutet:
    * genau zwischen beiden, usw.
    **/
   public final String lerpColor(String colorA, String colorB, double t);

   /**
    * Setzt den Modus, in dem nachfolgende Aufrufe von color(...) interpretiert werden. Möglich sind die Werte RGB, HSL und HSB.
    **/
   public final void colorMode(String mode);

   /**
    * Setzt den Modus, in dem nachfolgende Aufrufe von color(...) interpretiert werden. Möglich sind die Werte RGB, HSL und HSB für
    * Mode. Max ist der Maximalwert jeder Farbkomponente.
    **/
   public final void colorMode(String mode, double max);

   /**
    * Setzt den Modus, in dem nachfolgende Aufrufe von color(...) interpretiert werden. Möglich sind die Werte RGB, HSL und HSB für
    * Mode. Max ist der Maximalwert jeder Farbkomponente.
    **/
   public final void colorMode(String mode, double max1, double max2, double max3);

   /**
    * Setzt den Modus, in dem nachfolgende Aufrufe von color(...) interpretiert werden. Möglich sind die Werte RGB, HSL und HSB für
    * Mode. Max ist der Maximalwert jeder Farbkomponente.
    **/
   public final void colorMode(String mode, double max1, double max2, double max3, double maxAlpha);

   /**
    * Setzt den Modus, in dem nachfolgende Aufrufe von rect(...) interpretiert werden. Möglich sind die Werte CORNER, CORNERS, RADIUS
    * und CENTER.
    **/
   public final void rectMode(String mode);

   /**
    * Zeichnet ein Rechteck. (left, top) ist die linke obere Ecke, width die Breite und height die Höhe des Rechtecks.
    **/
   public final void rect(double left, double top, double width, double height);

   /**
    * Zeichnet ein Rechteck mit abgerundeten Ecken. (left, top) ist die linke obere Ecke, width die Breite und height die Höhe des
    * Rechtecks.
    **/
   public final void rect(double left, double top, double width, double height, double radius);

   /**
    * Zeichnet ein Rechteck mit abgerundeten Ecken. (left, top) ist die linke obere Ecke, width die Breite und height die Höhe des
    * Rechtecks.
    **/
   public final void rect(double left, double top, double width, double height, double radius1, double radius2, double radius3, double radius4);

   /**
    * Zeichnet ein Quadrat. (left, top) ist die linke obere Ecke, width Seitenlänge des Quadrats.
    **/
   public final void square(double left, double top, double width);

   /**
    * Zeichnet ein Quadrat mit abgerundeten Ecken. (left, top) ist die linke obere Ecke, width Seitenlänge des Quadrats. Radius ist
    * der Eckenradius.
    **/
   public final void square(double left, double top, double width, double radius);

   /**
    * Zeichnet ein Quadrat mit abgerundeten Ecken. (left, top) ist die linke obere Ecke, width Seitenlänge des Quadrats. Radius ist
    * der Eckenradius.
    **/
   public final void square(double left, double top, double width, double radius1, double radius2, double radius3, double radius4);

   /**
    * Zeichnet ein Rechteck. (left, top) ist die linke obere Ecke, width die Breite und height die Höhe des Rechtecks. Radius ist der
    * Eckenradius
    **/
   public final void rect(double left, double top, double width, double height, double radius);

   /**
    * Zeichnet eine Ellipse. (left, top) ist die linke obere Ecke der Boundingbox der Ellipse, width ihre Breite und height ihre Höhe.
    * Das lässt sich aber mit ellipseMode(...) ändern!
    **/
   public final void ellipse(double left, double top, double width, double height);

   /**
    * Zeichnet einen Kreis. (x, y) ist der Mittelpunkt des Kreises, extent der doppelte Radius.
    **/
   public final void circle(double x, double y, double extent);

   /**
    * Setzt den Modus, in dem nachfolgende Aufrufe von ellipse(...) interpretiert werden. Möglich sind die Werte CORNER, CORNERS,
    * RADIUS und CENTER.
    **/
   public final void ellipseMode(String mode);

   /**
    * Zeichnet eine Strecke von (x1, y1) nach (x2, y2).
    **/
   public final void line(double x1, double y1, double x2, double y2);

   /**
    * Zeichnet eine Strecke von (x1, y1, z1) nach (x2, y2, z2).
    **/
   public final void line(double x1, double y1, double z1, double x2, double y2, double z2);

   /**
    * Zeichnet eine Dreieck mit den Eckpunkten (x1, y1), (x2, y2) und (x3, y3).
    **/
   public final void triangle(double x1, double y1, double x2, double y2, double x3, double y3);

   /**
    * Zeichnet eine Viereck mit den Eckpunkten (x1, y1), (x2, y2), (x3, y3) und (x4, y4).
    **/
   public final void quad(double x1, double y1, double x2, double y2, double x3, double y3, double x4, double y4);

   /**
    * Zeichnet eine kubische Bezierkurve mit den Ankerpunkten (x1, y1), (x4, y4) und den Kontrollpunkten (x2, y2), (x3, y3).
    **/
   public final void bezier(double x1, double y1, double x2, double y2, double x3, double y3, double x4, double y4);

   /**
    * Zeichnet eine Catmull-Rom-Kurve vom Punkt (x2, y2) nach (x3, y3) so, als würde sie von (x1, x2) kommen und es am Ende zu (x4,
    * y4) weitergehen.
    **/
   public final void curve(double x1, double y1, double x2, double y2, double x3, double y3, double x4, double y4);

   /**
    * Will man die Zwischenpunkte einer Curve erhalten (Beginn b, Ende c, als würde sie von a kommen und nach d gehen), so verwendet
    * man sowohl für die x- als auch für die y-Koordinate diese Funktion. t gibt an, welchen Punkt der Kurve man haben möchte. t hat
    * Werte zwischen 0 (Startpunkt) und 1 (Endpunkt).
    **/
   public final float curvePoint(double a, double b, double c, double d, double t);

   /**
    * Will man die Zwischentangenten einer Curve erhalten (Beginn b, Ende c, als würde sie von a kommen und nach d gehen), so
    * verwendet man sowohl für die x- als auch für die y-Koordinate diese Funktion. t gibt an, welchen Punkt der Kurve man haben
    * möchte. t hat Werte zwischen 0 (Startpunkt) und 1 (Endpunkt).
    **/
   public final float curveTangent(double a, double b, double c, double d, double t);

   /**
    * Will man die Zwischenpunkte einer Bezierkurve erhalten (Ankerkoordinaten x1, x4 und Stützkoordinaten x2, x3), so nutzt man -
    * einzeln sowohl für die x- also auch für die y-Koordinate - diese Funktion. t gibt an, welchen Punkt der Kurve man haben möchte.
    * t hat Werte zwischen 0 (Startpunkt) und 1 (Endpunkt).
    **/
   public final float bezierPoint(double x1, double x2, double x3, double x4, double t);

   /**
    * Will man die Zwischentangenten einer Bezierkurve erhalten (Ankerkoordinaten x1, x4 und Stützkoordinaten x2, x3), so nutzt man -
    * einzeln sowohl für die x- also auch für die y-Koordinate - diese Funktion. t gibt an, welchen Punkt der Kurve man haben möchte.
    * t hat Werte zwischen 0 (Startpunkt) und 1 (Endpunkt).
    **/
   public final float bezierTangent(double x1, double x2, double x3, double x4, double t);

   /**
    * Beginnt mit dem Zeichnen eines Polygons. Die einzelnen Punkte werden mit der Methode vertex(x, y) gesetzt.
    **/
   public final void beginShape();

   /**
    * Endet das Zeichnen eines Polygons.
    **/
   public final void endShape();

   /**
    * Beginnt mit dem Zeichnen eines Polygons. Die einzelnen Punkte werden mit der Methode vertex(x, y) gesetzt. Mögliche Werte für
    * kind sind: POINTS, LINES, TRIANGLES, TRIANGLE_STRIP, TRIANGLE_FAN, QUADS, QUAD_STRIP
    **/
   public final void beginShape(String kind);

   /**
    * endShape(CLOSE) schließt den Linienzug.
    **/
   public final void endShape(String kind);

   /**
    * Setzt zwischen beginShape() und endShape() einen Punkt.
    **/
   public final void vertex(double x, double y);

   /**
    * Zeichnet einen Punkt.
    **/
   public final void point(double x, double y);

   /**
    * Setzt die Farbe des Pixels bei (x, y).
    **/
   public final void set(double x, double y, String color);

   /**
    * Setzt zwischen beginShape() und endShape() einen Punkt.
    **/
   public final void vertex(double x, double y, double z);

   /**
    * Zeichnet einen Punkt.
    **/
   public final void point(double x, double y, double z);

   /**
    * Setzt zwischen beginShape() und endShape() einen Punkt. Processing zeichnet damit eine Kurve nach dem Catmull-Rom-Algorithmus.
    **/
   public final void curveVertex(double x, double y);

   /**
    * Setzt zwischen beginShape() und endShape() einen Punkt. Processing zeichnet damit eine Kurve nach dem Catmull-Rom-Algorithmus.
    **/
   public final void curvevertex(double x, double y, double z);

   /**
    * Zeichnet einen 3D-Würfel mit der Seitenlänge size.
    **/
   public final void box(double size);

   /**
    * Zeichnet einen 3D-Würfel mit den angegebenen Seitenlängen.
    **/
   public final void box(double sizeX, double sizeY, double sizeZ);

   /**
    * Setzt alle erfolgten Transformationen zurück.
    **/
   public final void resetMatrix();

   /**
    * Sichert den aktuellen Zeichenzustand, d.h. die Farben und Transformationen, auf einen Stack.
    **/
   public final void push();

   /**
    * Holt den obersten Zeichenzustand, d.h. die Farben und Transformationen, vom Stack.
    **/
   public final void pop();

   /**
    * Streckt die nachfolgend gezeichneten Figuren.
    **/
   public final void scale(double factor);

   /**
    * Streckt die nachfolgend gezeichneten Figuren.
    **/
   public final void scale(double factorX, double factorY);

   /**
    * Streckt die nachfolgend gezeichneten Figuren.
    **/
   public final void scale(double factorX, double factorY, double factorZ);

   /**
    * Verschiebt die nachfolgend gezeichneten Figuren.
    **/
   public final void translate(double x, double y);

   /**
    * Verschiebt die nachfolgend gezeichneten Figuren.
    **/
   public final void translate(double x, double y, double z);

   /**
    * Rotiert die nachfolgend gezeichneten Figuren. Mit angleMode(RADIANS) bzw. angleMode(DEGREES) kann beeinflusst werden, wie angle
    * interpretiert wird. Default ist RADIANS.
    **/
   public final void rotate(double angle);

   /**
    * Rotiert die nachfolgend gezeichneten Figuren um die X-Achse. Mit angleMode(RADIANS) bzw. angleMode(DEGREES) kann beeinflusst
    * werden, wie angle interpretiert wird. Default ist RADIANS.
    **/
   public final void rotateX(double angle);

   /**
    * Rotiert die nachfolgend gezeichneten Figuren um die Y-Achse. Mit angleMode(RADIANS) bzw. angleMode(DEGREES) kann beeinflusst
    * werden, wie angle interpretiert wird. Default ist RADIANS.
    **/
   public final void rotateY(double angle);

   /**
    * Schert die nachfolgend gezeichneten Figuren in Richtung derX-Achse. Mit angleMode(RADIANS) bzw. angleMode(DEGREES) kann
    * beeinflusst werden, wie angle interpretiert wird. Default ist RADIANS.
    **/
   public final void shearX(double angle);

   /**
    * Schert die nachfolgend gezeichneten Figuren in Richtung der Y-Achse. Mit angleMode(RADIANS) bzw. angleMode(DEGREES) kann
    * beeinflusst werden, wie angle interpretiert wird. Default ist RADIANS.
    **/
   public final void shearY(double angle);

   /**
    * Rotiert die nachfolgend gezeichneten Figuren um die Z-Achse. Mit angleMode(RADIANS) bzw. angleMode(DEGREES) kann beeinflusst
    * werden, wie angle interpretiert wird. Default ist RADIANS.
    **/
   public final void rotateZ(double angle);

   /**
    * Mit angleMode(RADIANS) bzw. angleMode(DEGREES) kann beeinflusst werden, wie winkel bei Rotationen interpretiert werden. Default
    * ist RADIANS.
    **/
   public final void angleMode(String mode);

   /**
    * Setzt die Schriftgröße in Pixel.
    **/
   public final void textSize(double size);

   /**
    * Setzt die Ausrichtung des nächsten ausgegebenen Textes in x-Richtung. Mögliche Werte sind CENTER, LEFT, RIGHT
    **/
   public final void textAlign(int alignX);

   /**
    * Setzt die Ausrichtung des nächsten ausgegebenen Textes. Mögliche Werte für alignX sind CENTER, LEFT, RIGHT, mögliche Werte für
    * alignY sind TOP, CENTER, BASELINE, BOTTOM
    **/
   public final void textAlign(int alignX, int alignY);

   /**
    * Gibt Text aus.
    **/
   public final void text(String text, double x, double y);

   /**
    * Gibt Text aus. x2 und y2 sind die Breite und Höhe des Textausgabebereichs. Hat der Text horizontal nicht Platz, so wird er
    * entsprechend umgebrochen.
    **/
   public final void text(String text, double x, double y, double x2, double y2);

   /**
    * Gibt eine Zufallszahl zwischen low und high zurück.
    **/
   public final float random(double low, double high);

   /**
    * Gibt eine Zufallszahl zwischen 0 und high zurück.
    **/
   public final float random(double high);

   /**
    * Gibt die Quadratwurzel von n zurück.
    **/
   public final float sqrt(double n);

   /**
    * Gibt die den Wert der Potenz ("basis hoch exponent") zurück.
    **/
   public final float pow(double basis, double exponent);

   /**
    * Gibt den größeren der beiden Werte zurück.
    **/
   public final float max(double a, double b);

   /**
    * Gibt den kleineren der beiden Werte zurück.
    **/
   public final float min(double a, double b);

   /**
    * Gibt den Betrag des Wertes zurück.
    **/
   public final float abs(double n);

   /**
    * Gibt den Sinus des Wertes zurück.
    **/
   public final float sin(double n);

   /**
    * Gibt den Cosinus des Wertes zurück.
    **/
   public final float cos(double n);

   /**
    * Gibt den Tangens des Wertes zurück.
    **/
   public final float tan(double n);

   /**
    * Gibt den Arcussinus des Wertes zurück.
    **/
   public final float asin(double n);

   /**
    * Gibt den Arcussosinus des Wertes zurück.
    **/
   public final float acos(double n);

   /**
    * Wandelt einen Winkel vom Gradmaß ins Bogenmaß um.
    **/
   public final float radians(double angle);

   /**
    * Wandelt einen Winkel vom Bogenmaß ins Gradmaß um.
    **/
   public final float degrees(double angle);

   /**
    * Gibt den Arcussangens des Wertes zurück.
    **/
   public final float atan(double n);

   /**
    * Gibt den Arcussangens des Wertes zurück.
    **/
   public final float atan2(double x, double y);

   /**
    * Gibt die Quadratwurzel des Wertes zurück.
    **/
   public final float sqrt(double x, double y);

   /**
    * Gibt das Quadrat des Wertes zurück.
    **/
   public final float sq(double x, double y);

   /**
    * Gibt den Betrag des Wertes zurück.
    **/
   public final int abs(int n);

   /**
    * Rundet den Wert auf eine ganze Zahl.
    **/
   public final int round(double n);

   /**
    * Rundet den Wert auf eine ganze Zahl (Aufrunden!).
    **/
   public final int ceil(double n);

   /**
    * Rundet den Wert auf eine ganze Zahl (Abfrunden!).
    **/
   public final int floor(double n);

   /**
    * Berechnet den Abstand der Punkte (x1, y1) und (x2, y2).
    **/
   public final float dist(double x1, double y1, double x2, double y2);

   /**
    * Berechnet den a + (b - a)*t. Wählt man t zwischen 0 und 1, so kann man damit die Zwischenwerte zwischen a und b errechnen.
    **/
   public final float lerp(double a, double b, double t);

   /**
    * Beschränkt value auf den Bereich [min, max], genauer: Ist value < min, so wird min zurückgegeben. Ist value > max, so wird max
    * zurückgegeben. Ansonsten wird value zurückgegeben.
    **/
   public final float constrain(double value, double min, double max);

   /**
    * Aktuelle Jahreszahl
    **/
   public final int year();

   /**
    * Monat: 1 == Januar, 12 == Dezember
    **/
   public final int month();

   /**
    * Tag (innerhalb des Monats) des aktuellen Datums
    **/
   public final int day();

   /**
    * Stundenzahl der aktuellen Uhrzeit
    **/
   public final int hour();

   /**
    * Minutenzahl der aktuellen Uhrzeit
    **/
   public final int minute();

   /**
    * Sekundenzahl der aktuellen Uhrzeit
    **/
   public final int second();

   /**
    * Setzt die Framerate (Anzahl der Aufrufe von draw() pro Sekunde)
    **/
   public final void frameRate(int n);

   /**
    * Gibt die Breite des Texts zurück.
    **/
   public final float textWidth(String text);

   /**
    * Gibt den Ascent Textes zurück ( = Höhe des größten Zeichens über der Grundlinie).
    **/
   public final float textAscent(String text);

   /**
    * Gibt den Descent Textes zurück ( = Tiefe des tiefsten Zeichens unter der Grundlinie).
    **/
   public final float textDescent(String text);

   /**
    * Setzt den Abstand zweier aufeinanderfolgender Textzeilen.
    **/
   public final void textLeading(double leading);

   /**
    * Ändert das Aussehen des Mauscursors. Type ist einer der Werte "arrow", "cross", "text", "move", "hand", "wait", "progress".
    **/
   public final void cursor(String type);

   /**
    * Hat zur Folge, dass der Mauscursor über dem Zeichenbereich unsichtbar ist.
    **/
   public final void noCursor(String type);

   /**
    * Kopiert den rechteckigen Bereich mit der linken oberen Ecke (sx, sy) sowie der Breite sw und der Höhe sh in den Bereich mit der
    * linken oberen Ecke (dx, dy), der Breite dw und der Höhe dh.
    **/
   public final void copy(double sx, double sy, double sw, double sh, double dx, double dy, double dw, double dh);

   /**
    * Gibt die Millisekunden zurück, die vergangen sind, seit setup() aufgerufen wurde.
    **/
   public final void millis();

   /**
    * Führt draw() genau ein Mal aus. Macht ggf. Sinn, wenn die Render-Loop zuvor mit noLoop() gestoppt wurde.
    **/
   public final void redraw();

}

public class PerspectiveCamera3d {
   public PerspectiveCamera3d(double fov, double aspect, double near, double far);

   public void setViewport(double xRel, double yRel, double widthRel, double heightRel);

}

/**
 * Dieses Material verwendet ein nichtphysikalisches Blinn-Phong-Modell zur Berechnung des Reflexionsgrads. kann glänzende
 * Oberflächen mit spiegelnden Glanzlichtern simulieren (z. B. lackiertes Holz). MeshPhongMaterial berechnet die Schattierung je
 * Fragment (entspricht ca. einem Bildschirmpixel). Der Parameter Shininess (0...1000) definiert die Intensität dieser
 * Glanzlichter.
 **/
public class PhongMaterial3d {
   /**
    * Legt fest, ob das Objekt ungefüllt (nur als Gitter) gezeichnet werden soll.
    **/
   public boolean wireframe;
   /**
    * Erzeugt ein PhongMaterial-Objekt. Der Parameter Shininess (0...1000) definiert die Intensität der Glanzlichter.
    **/
   public PhongMaterial3d(int color);

   /**
    * Erzeugt ein PhongMaterial-Objekt. Der Parameter Shininess (0...1000) definiert die Intensität der Glanzlichter.
    **/
   public PhongMaterial3d(int color, double shininess);

   /**
    * Erzeugt ein PhongMaterial-Objekt. Der Parameter Shininess (0...1000) definiert die Intensität der Glanzlichter.
    **/
   public PhongMaterial3d(String color, double shininess);

   /**
    * Erzeugt ein PhongMaterial-Objekt. Der Parameter Shininess (0...1000) definiert die Intensität der Glanzlichter.
    **/
   public PhongMaterial3d(Color color, double shininess);

   /**
    * Erzeugt ein PhongMaterial-Objekt mit einer Textur, z.B. new PhongMaterial(Texture.earth2k).
    **/
   public PhongMaterial3d(Texture texture);

   /**
    * Erzeugt ein PhongMaterial-Objekt mit einer Textur, z.B. new PhongMaterial(SpriteLibrary.plattforms, 20).
    **/
   public PhongMaterial3d(SpriteLibrary spriteLibrary, int imageIndex);

   /**
    * Die Shininess (0...1000) des Materials definiert die Intensität der Glanzlichter.
    **/
   public void setShininess(double shininess);

   /**
    * Die Shininess (0...1000) des Materials definiert die Intensität der Glanzlichter.
    **/
   public double getShininess();

   /**
    * Farbe der Glanzlichter
    **/
   public void setSpecular(int color);

   /**
    * Farbe der Glanzlichter
    **/
   public void setSpecular(String color);

   /**
    * Farbe der Glanzlichter
    **/
   public void setSpecular(Color color);

   /**
    * Farbe der Glanzlichter
    **/
   public int getSpecular();

   /**
    * Farbe, mit der das Objekt selbst leuchtet.
    **/
   public void setEmissive(int color);

   /**
    * Farbe, mit der das Objekt selbst leuchtet.
    **/
   public void setEmissive(String color);

   /**
    * Farbe, mit der das Objekt selbst leuchtet.
    **/
   public void setEmissive(Color color);

   /**
    * Farbe, mit der das Objekt selbst leuchtet.
    **/
   public int getEmissive();

   /**
    * Legt fest, ob das Objekt ungefüllt (nur als Gitter) gezeichnet werden soll.
    **/
   public boolean isWireframe();

   /**
    * Legt fest, ob das Objekt ungefüllt (nur als Gitter) gezeichnet werden soll.
    **/
   public void setWireframe(boolean value);

}

/**
 * in Standardmaterial auf physikalischer Basis. Physically Based Rendering (PBR) ist in vielen 3D-Anwendungen wie Unity, Unreal
 * und 3D Studio Max in letzter Zeit zum Standard geworden.
 *     Dieser Ansatz unterscheidet sich von älteren Ansätzen dadurch, dass statt Näherungen für die Art und Weise, wie Licht mit
 * einer Oberfläche interagiert, ein physikalisch korrektes Modell verwendet wird.
 *     In der Praxis liefert dies ein genaueres und realistischeres Ergebnis als LambertMaterial oder PhongMaterial, allerdings ist
 * der Rechenaufwand etwas höher.
 **/
public class PhysicallyBasedMaterial3d {
   /**
    * Legt fest, ob das Objekt ungefüllt (nur als Gitter) gezeichnet werden soll.
    **/
   public boolean wireframe;
   /**
    * Erzeugt ein neues PhysicallyBasedMaterial-Objekt
    **/
   public PhysicallyBasedMaterial3d(int color, double routhness, double metalness);

   /**
    * Erzeugt ein neues PhysicallyBasedMaterial-Objekt
    **/
   public PhysicallyBasedMaterial3d(String color, double routhness, double metalness);

   /**
    * Erzeugt ein neues PhysicallyBasedMaterial-Objekt
    **/
   public PhysicallyBasedMaterial3d(Color color, double routhness, double metalness);

   /**
    * Erzeugt ein PhysicallyBasedMaterial-Objekt mit einer Textur, z.B. new PhysicallyBasedMaterial(Texture.earth2k).
    **/
   public PhysicallyBasedMaterial3d(Texture texture);

   /**
    * Erzeugt ein PhysicallyBasedMaterial-Objekt mit einer Textur, z.B. new PhysicallyBasedMaterial(SpriteLibrary.plattforms, 20).
    **/
   public PhysicallyBasedMaterial3d(SpriteLibrary spriteLibrary, int imageIndex);

   /**
    * Farbe, mit der das Objekt selbst leuchtet.
    **/
   public void setEmissive(int color);

   /**
    * Farbe, mit der das Objekt selbst leuchtet.
    **/
   public void setEmissive(String color);

   /**
    * Farbe, mit der das Objekt selbst leuchtet.
    **/
   public void setEmissive(Color color);

   /**
    * Farbe, mit der das Objekt selbst leuchtet.
    **/
   public int getEmissive();

   /**
    * Legt fest, ob das Objekt ungefüllt (nur als Gitter) gezeichnet werden soll.
    **/
   public boolean isWireframe();

   /**
    * Legt fest, ob das Objekt ungefüllt (nur als Gitter) gezeichnet werden soll.
    **/
   public void setWireframe(boolean value);

   /**
    * Rauheit des Materials (Wert zwischen 0 und 1)
    **/
   public void setRoughness(double value);

   /**
    * Rauheit des Materials (Wert zwischen 0 und 1)
    **/
   public double getRoughness(double value);

   /**
    * Metallisches Reflektieren des Materials (Wert zwischen 0 und 1)
    **/
   public void setMetalness(double value);

   /**
    * Metallisches Reflektieren des Materials (Wert zwischen 0 und 1)
    **/
   public double getMetalness(double value);

}

public class Plane3d {
   public Plane3d(double width, double height, int widthSegments, int heightSegments);

   public Plane3d(double width, double height);

   public Plane3d();

}

public class PointLight3d {
   public PointLight3d();

   public PointLight3d(double x, double y, double z);

   public PointLight3d(Vector3 position);

}

/**
 * Polygon
 **/
public class Polygon {
   /**
    * Instanziert ein neues Polygon. Der Standardkonstruktor ohne Parameter instanziert ein regelmäßiges Sechseck. 
    * Tipp: Es gibt auch Konstruktoren, denen man ein Array von Koordinaten bzw. einzelne Koordinaten übergeben kann!
    **/
   public Polygon();

   /**
    * Instanziert ein neues Polygon. Der Standardkonstruktor ohne Parameter instanziert ein regelmäßiges Sechseck. 
    * Tipp: Es gibt auch Konstruktoren, denen man ein Array von Koordinaten bzw. einzelne Koordinaten übergeben kann!
    **/
   public Polygon(boolean closeAndFill);

   /**
    * Instanziert ein neues Polygon. Die Punkte werden als double-Werte der Form x1, y1, x2, y2, ... übergeben.
    **/
   public Polygon(boolean closeAndFill, double[] coordinates);

   /**
    * Instanziert ein neues Polygon. Die Punkte werden als Array von double-Werten der Form {x1, y1, x2, y2, ...} übergeben.
    **/
   public Polygon(boolean closeAndFill, double[] coordinates);

   /**
    * Instanziert ein neues Polygon. Seine Punkte sind die Punkte des Hitpolygons der übergebenen Figur.
    **/
   public Polygon(Shape shape);

   /**
    * Fügt dem Polygon einen Punkt hinzu.
    **/
   public void addPoint(double x, double y);

   /**
    * Löscht alle Punkte des Polygons und setzt komplett neue. Diese werden in einem double[] übergeben, das abwechselnd die x- und
    * y-Koordinaten enthält.
    **/
   public void setPoints(double[] points);

   /**
    * Fügt dem Polygon mehrere Punkte hinzu. Diese werden in einem double[] übergeben, das abwechselnd die x- und y-Koordinaten
    * enthält.
    **/
   public void addPoints(double[] points);

   /**
    * Fügt dem Polygon einen Punkt als 'index-ter' Punkt hinzu. index == 0 => ganz am Anfang; index == Anzahl der bisherigen Punkte =>
    * ganz am Ende;
    **/
   public void insertPoint(double x, double y, int index);

   /**
    * Verschiebt Punkt mit dem angegebenen Index nach (x, y). Index == 0 => erster Punkt, index == 1 => zweiter Punkt usw.
    **/
   public void movePointTo(double x, double y, int index);

   /**
    * Öffnet das Polygon, indem des die Strecke zwischen erstem und letzem Punkt entfernt. Diese Methode hat bei gefüllten Polygonen
    * keinen Effekt.
    **/
   public void open();

   /**
    * Schließt das Polygon, indem es den ersten und letzten Punkt mit einer Strecke verbindet. Diese Methode hat bei gefüllten
    * Polygonen keinen Effekt.
    **/
   public void close();

   /**
    * Gibt genau dann true zurück, wenn die Figur den angegebenen Punkt enthält.
    **/
   public final boolean containsPoint(double x, double y);

   /**
    * Erstellt eine Kopie des polygon-Objekts und git sie zurück.
    **/
   public final Polygon copy();

   /**
    * Wandelt das Objekt in eine Zeichenkette um und liefert diese zurück.
    **/
   public String toString();

}

/**
 * Repräsentiert einen Position auf einem Gitternetz (nur ganzzahlige Koordinaten)
 **/
public class Position {
   /**
    * x-Komponente der Position
    **/
   public int x;
   /**
    * y-Komponente der Position
    **/
   public int y;
   /**
    * Instanziert eine neue Position den Komponenten x und y.
    **/
   public Position(int x, int y);

   /**
    * Wandelt das Objekt in eine Zeichenkette um und liefert diese zurück.
    **/
   public String toString();

}

public interface Predicate<T> {
   public boolean test(T t);

}

/**
 * Interne Hilfsklasse, um System.out.println zu ermöglichen. Das Objekt System.out ist von der Klasse PrintStream.
 **/
public class PrintStream {
   /**
    * Gibt den Text aus.
    **/
   public void print(String text);

   /**
    * Gibt den Text aus.
    **/
   public void print(int number);

   /**
    * Gibt den Text aus.
    **/
   public void print(double number);

   /**
    * Gibt den Text aus.
    **/
   public void print(boolean b);

   /**
    * Gibt den Text aus, gefolgt von einem Zeilenumbruch.
    **/
   public void println(String text);

   /**
    * Gibt den Text aus, gefolgt von einem Zeilenumbruch.
    **/
   public void println(int number);

   /**
    * Gibt den Text aus, gefolgt von einem Zeilenumbruch.
    **/
   public void println(double number);

   /**
    * Gibt den Text aus, gefolgt von einem Zeilenumbruch.
    **/
   public void println(boolean b);

   /**
    * Gibt einen Zeilenumbruch aus.
    **/
   public void println();

}

/**
 * Missing template for language de
 **/
public interface Queue<E> {
   /**
    * Entfernt das Element am Kopf der Liste und gibt es zurück. Führt zum Fehler, wenn die Liste leer ist.
    **/
   public E remove();

   /**
    * Entfernt das Element am Kopf der Liste und gibt es zurück. Gibt null zurück, wenn die Liste leer ist.
    **/
   public E poll();

   /**
    * Gibt das Element am Kopf der Liste zurück, entfernt es aber nicht. Gib null zurück, wenn die Liste leer ist.
    **/
   public E peek();

   /**
    * Fügt ein Element hinten an die Liste an. Gibt true zurück, wenn das Element eingefügt werden konnte, ansonsten false.
    **/
   public boolean offer(E element);

}

/**
 * Radiobutton, der innerhalb der Grafikausgabe dargestellt werden kann
 **/
public class RadioButton {
   /**
    * Instanziert ein neues Radiobutton-Objekt. (x, y) sind die Koordinaten der linken oberen Ecke, fontsize die Höhe des Textes in
    * Pixeln.
    **/
   public RadioButton(double x, double y, double width, double fontsize, String text, int index);

   /**
    * Instanziert ein neues Radiobutton-Objekt. (x, y) sind die Koordinaten der linken oberen Ecke, fontsize die Höhe des Textes in
    * Pixeln.
    **/
   public RadioButton(double x, double y, double width, double fontsize, String text, String fontFamily, int index);

   /**
    * Erstellt eine Kopie des Radiobutton.
    **/
   public RadioButton copy();

   /**
    * Gibt den Index des Radiobuttons zurück.
    **/
   public int getIndex();

   /**
    * Sind mehrere Radiobuttons mittels connectTo mit dieserm logisch verbunden, so ist genau einer davon selektiert. Diese Methode
    * gibt den Index dieses selektierten Radiobuttons zurück.
    **/
   public int getIndexOfSelectedRadiobutton();

   /**
    * Sind mehrere Radiobuttons mittels connectTo mit dieserm logisch verbunden, so ist genau einer davon selektiert. Diese Methode
    * gibt den Text dieses selektierten Radiobuttons zurück.
    **/
   public int getTextOfSelectedRadiobutton();

   /**
    * Setzt den Index des Radiobuttons.
    **/
   public void setIndex();

   /**
    * Setzt die Farbe des Punktes. Die Farbe wird als int-Wert gegeben, wobei farbe == 256*256*rot + 256*grün + blau
    **/
   public void setDotColor();

   /**
    * Verbindet diesen Radiobutton logisch mit den anderen Radiobuttons. Wird anschließend auf einen davon geklickt, so wird dieser
    * selektiert, die anderen deselektiert.
    **/
   public void connectTo(RadioButton[] otherButtons);

   /**
    * Selektiert diesen Radiobutton und deselektiert alle via connectTo mit ihm verbundenen Radiobuttons.
    **/
   public void select();

   /**
    * Gibt genau dann true zurück, falls die RadioButton selektiert ist.
    **/
   public boolean isSelected();

}

/**
 * Die Klasse Random stellt Methoden zur Erzeugung von Zufallszahlen zur Verfügung.
 **/
public class Random {
   public Random();

   /**
    * Gibt eine ganze Zufallszahl aus dem Bereich {from, from + 1, ... , to} zurück.
    **/
   public static int randint(int from, int to);

   /**
    * Gibt eine ganzzahlige Zufallszahl aus der Menge {0, 1, ..., bound - 1} zurück.
    **/
   public final int nextInt(int to);

   /**
    * Gibt eine ganze Zufallszahl aus dem Bereich [from, to[ zurück.
    **/
   public static double randdouble(double from, double to);

}

/**
 * Ein Objekt der Klasse Rectangle zeichnet ein Rechteck in den Grafikbereich.
 **/
public class Rectangle {
   /**
    * Instanziert ein Retangle-Objekt mit Standardmaßen. Seine linke obere Ecke liegt bei (0/0). Breite und Höhe betragen jeweils 100.
    * Die Rechteckseiten sind zunächst parallel zu den Koordinatenachsen.
    **/
   public Rectangle();

   /**
    * Instanziert ein Retangle-Objekt. Seine linke obere Ecke liegt bei (top/left). Width ist seine Breite, height seine Höhe. Das
    * Rechteck ist zunächst achsenparallel.
    **/
   public Rectangle(double left, double top, double width, double height);

   /**
    * setzt die Breite des Rechtecks.
    **/
   public final void setWidth(double width);

   /**
    * setzt die Höhe des Rechtecks.
    **/
   public final void setHeight(double height);

   /**
    * gibt die Breite des Rechtecks zurück
    **/
   public final double getWidth();

   /**
    * gibt die Höhe des Rechtecks zurück
    **/
   public final double getHeight();

   /**
    * Erstellt eine Kopie des Rectangle-Objekts und git sie zurück.
    **/
   public final Rectangle copy();

   /**
    * Verschiebt das Grafikobjekt so, dass sich sein Diagonalenschnittpunkt an den angegebenen Koordinaten befindet.
    **/
   public final void moveTo(double x, double y);

   /**
    * Wandelt das Objekt in eine Zeichenkette um und liefert diese zurück.
    **/
   public String toString();

}

/**
 * Gibt an, auf welche Art eine Sprite-Animation wiederholt werden soll.
 **/
public enum RepeatType {
   once, loop, backAndForth;

   public static RepeatType[] values();

   public static RepeatType valueOf(String name);

}

public class Ring3d {
   public Ring3d(double innerRadius, double outerRadius, int thetaSegments, int phiSegments, double thetaStart, double thetaLength);

   public Ring3d(double innerRadius, double outerRadius, int thetaSegments, int phiSegments);

   public Ring3d(double innerRadius, double outerRadius);

   public Ring3d();

}

/**
 * Robot Karol
 **/
public class Robot {
   /**
    * Instanziert ein neues Robot-Objekt. Der Roboter steht anfangs an der Stelle (1/1)'
    **/
   public Robot();

   /**
    * Instanziert ein neues Robot-Objekt. Der Roboter wird anfangs an die Stelle (startX/startY) gesetzt.
    **/
   public Robot(int startX, int startY);

   /**
    * Instanziert ein neues Robot-Objekt. Der Roboter wird anfangs an die Stelle (startX/startY) gesetzt. WorldX und WorldY sind die
    * Ausmaße der Welt.
    **/
   public Robot(int startX, int startY, int worldX, int worldY);

   /**
    * Instanziert ein neues Robot-Objekt. Der Roboter wird anfangs an die Stelle (startX/startY) gesetzt. Wenn die RobotWorld noch
    * nicht instanziert ist, wird sie auf Grundlage des Strings initialeWelt erstellt.
    **/
   public Robot(int startX, int startY, String initialWorld);

   /**
    * Gibt das RobotWorld-Objekt zurück
    **/
   public RobotWorld getWelt();

   /**
    * Dreht den Roboter um 90° nach rechts.
    **/
   public void rechtsDrehen();

   /**
    * Dreht den Roboter um 90° nach links.
    **/
   public void linksDrehen();

   /**
    * Lässt den Roboter einen Schritt nach vorne gehen.
    **/
   public void schritt();

   /**
    * Lässt den Roboter anzahl Schritte nach vorne gehen.
    **/
   public void schritt(int anzahl);

   /**
    * Lässt den Roboter einen roten Ziegel vor sich hinlegen.
    **/
   public void hinlegen();

   /**
    * Lässt den Roboter einen roten Ziegel vor sich hinlegen.
    **/
   public void hinlegen(int n);

   /**
    * Lässt den Roboter einen Ziegel der angegebenen Farbe vor sich hinlegen.
    **/
   public void hinlegen(String farbe);

   /**
    * Lässt den Roboter eine gelbe Marke direkt unter sich setzen.
    **/
   public void markeSetzen();

   /**
    * Lässt den Roboter eine Marke der angegebenen Farbe direkt unter sich setzen.
    **/
   public void markeSetzen(String farbe);

   /**
    * Lässt den Roboter eine Marke, die direkt unter ihm liegt, löschen.
    **/
   public void markeLöschen();

   /**
    * Lässt den Roboter einen roten Ziegel vor sich aufheben.
    **/
   public void aufheben();

   /**
    * Lässt den Roboter einen roten Ziegel vor sich aufheben.
    **/
   public void aufheben(int n);

   /**
    * Beendet das Programm
    **/
   public void beenden();

   /**
    * Gibt genau dann true zurück, wenn der Roboter direkt vor einer Wand steht.
    **/
   public boolean istWand();

   /**
    * Gibt genau dann true zurück, wenn der Roboter nicht direkt vor einer Wand steht.
    **/
   public boolean nichtIstWand();

   /**
    * Gibt genau dann true zurück, wenn direkt vor dem Roboter mindestens ein Ziegel liegt.
    **/
   public boolean istZiegel();

   /**
    * Gibt genau dann true zurück, wenn direkt vor dem Roboter genau Anzahl Ziegel liegen.
    **/
   public boolean istZiegel(int anzahl);

   /**
    * Gibt genau dann true zurück, wenn auf dem Ziegelstapel direkt vor dem Roboter mindestens ein Ziegel mit der angegebenen Farbe
    * liegt.
    **/
   public boolean istZiegel(String farbe);

   /**
    * Gibt genau dann true zurück, wenn direkt vor dem Roboter kein Ziegel liegt.
    **/
   public boolean nichtIstZiegel();

   /**
    * Gibt genau dann true zurück, wenn direkt vor dem Roboter nicht genau Anzahl Ziegel liegen.
    **/
   public boolean nichtIstZiegel(int anzahl);

   /**
    * Gibt genau dann true zurück, wenn auf dem Ziegelstapel direkt vor dem Roboter kein Ziegel mit der angegebenen Farbe liegt.
    **/
   public boolean nichtIstZiegel(String farbe);

   /**
    * Gibt genau dann true zurück, wenn unter dem Roboter eine Marke (egal in welcher Farbe) liegt.
    **/
   public boolean istMarke();

   /**
    * Gibt genau dann true zurück, wenn unter dem Roboter eine Marke in der angegebenen Farbe liegt.
    **/
   public boolean istMarke(String farbe);

   /**
    * Gibt genau dann true zurück, wenn unter dem Roboter keine Marke (egal in welcher Farbe) liegt.
    **/
   public boolean nichtIstMarke();

   /**
    * Gibt genau dann true zurück, wenn unter dem Roboter keine Marke in der angegebenen Farbe liegt.
    **/
   public boolean nichtIstMarke(String farbe);

   /**
    * Gibt genau dann true zurück, wenn der Roboter nach Norden blickt.
    **/
   public boolean istNorden();

   /**
    * Gibt genau dann true zurück, wenn der Roboter nach Süden blickt.
    **/
   public boolean istSüden();

   /**
    * Gibt genau dann true zurück, wenn der Roboter nach Osten blickt.
    **/
   public boolean istOsten();

   /**
    * Gibt genau dann true zurück, wenn der Roboter nach Westen blickt.
    **/
   public boolean istWesten();

   /**
    * Gibt genau dann true zurück, wenn der Roboter keinen Stein mit sich trägt.
    **/
   public boolean istLeer();

   /**
    * Gibt genau dann true zurück, wenn der Roboter mindestens einen Stein mit sich trägt.
    **/
   public boolean nichtIstLeer();

   /**
    * Gibt genau dann true zurück, wenn der Roboter die maximale Anzahl von Steinen mit sich trägt.
    **/
   public boolean istVoll();

   /**
    * Gibt genau dann true zurück, wenn der Roboter weniger als die maximale Anzahl von Steinen mit sich trägt.
    **/
   public boolean nichtIstVoll();

   /**
    * Gibt genau dann true zurück, wenn der Roboter mindestens einen Stein mit sich trägt.
    **/
   public boolean hatZiegel();

   /**
    * Befüllt den Rucksack des Roboters mit genau Anzahl Steinen.
    **/
   public void setzeAnzahlSteine(int anzahl);

   /**
    * Gibt dem Roboter einen Rucksack, der maximal Anzahl Steine fasst.
    **/
   public void setzeRucksackGröße(int anzahl);

}

/**
 * Welt für Robot Karol
 **/
public class RobotWorld {
   /**
    * Instanziert eine neue Robot-Welt
    **/
   public RobotWorld(int worldX, int worldY);

   /**
    * Instanziert eine neue Robot-Welt
    **/
   public RobotWorld(String initialeWelt);

   /**
    * Ändert die maximale Höhe der Ziegelstapel.
    **/
   public void setzeMaximalhöhe(int hoehe);

   /**
    * Setzt Anzahl Ziegel an der angegebenen Position mit der angegebenen Farbe. Die x- und y-Koordinaten beginnen bei 1.
    **/
   public void setzeZiegel(int x, int y, String farbe, int anzahl);

   /**
    * Setzt einen Marker an der angegebenen Position mit der angegebenen Farbe. Die x- und y-Koordinaten beginnen bei 1.
    **/
   public void setzeMarke(int x, int y, String farbe);

}

/**
 * Ein Objekt der Klasse RoundedRectangle zeichnet ein Rechteck in den Grafikbereich.
 **/
public class RoundedRectangle {
   /**
    * Instanziert ein Retangle-Objekt mit Standardmaßen. Seine linke obere Ecke liegt bei (0/0). Breite und Höhe betragen jeweils 100.
    * Die Rechteckseiten sind zunächst parallel zu den Koordinatenachsen.
    **/
   public RoundedRectangle();

   /**
    * Instanziert ein Retangle-Objekt. Seine linke obere Ecke liegt bei (top/left). Width ist seine Breite, height seine Höhe. Das
    * Rechteck ist zunächst achsenparallel.
    **/
   public RoundedRectangle(double left, double top, double width, double height, double radius);

   /**
    * setzt die Breite des Rechtecks.
    **/
   public final void setWidth(double width);

   /**
    * setzt die Höhe des Rechtecks.
    **/
   public final void setHeight(double height);

   /**
    * gibt die Breite des Rechtecks zurück
    **/
   public final double getWidth();

   /**
    * gibt die Höhe des Rechtecks zurück
    **/
   public final double getHeight();

   /**
    * Erstellt eine Kopie des RoundedRectangle-Objekts und git sie zurück.
    **/
   public final RoundedRectangle copy();

   /**
    * Verschiebt das Grafikobjekt so, dass sich sein Diagonalenschnittpunkt an den angegebenen Koordinaten befindet.
    **/
   public final void moveTo(double x, double y);

   /**
    * Wandelt das Objekt in eine Zeichenkette um und liefert diese zurück.
    **/
   public String toString();

}

/**
 * Das Runnable-Interface wird von Klassen implementiert, die eine Methode run() besitzen, die in einem neuen Thread ausgeführt
 * werden soll.
 **/
public interface Runnable {
   /**
    * WEnn ein Objekt, das das Interface Runnable implementiert, benutzt wird, um einen Thread zu erstellen, bewirkt das Starten des
    * Threads die Ausführung der run()-Methode in diesem Thread.
    **/
   public void run();

}

public class RuntimeException {
   public RuntimeException();

   public RuntimeException(String message);

   public RuntimeException(Throwable cause);

   public RuntimeException(String message, Throwable cause);

   public String toString();

}

/**
 * Art der Interpolation der Pixelfarben beim Skalieren von Sprites
 **/
public enum ScaleMode {
   linear, nearest_neighbour;

   public static ScaleMode[] values();

   public static ScaleMode valueOf(String name);

}

/**
 * Kreisbogen/Kreissektor
 **/
public class Sector {
   /**
    * Instanziert einen neuen Kreisbogen.
    **/
   public Sector();

   /**
    * Instanziert einen neuen Kreisbogen. (mx, my) ist der Mittelpunt, ri sein Innenradius, ra sein Außenradius. Der Kreisbogen wird
    * von startAngle bis endAngle (beides in Grad) gegen den Uhrzeigersinn gezogen.
    **/
   public Sector(double mx, double my, double radius, double startAngle, double endAngle);

   /**
    * Setzt den Innenradius des Kreisbogens.
    **/
   public final void setInnerRadius(double innerRadius);

   /**
    * Liefert den Innenradius des Kreisbogens.
    **/
   public final double getInnerRadiusX();

   /**
    * Setzt den Startwinkel des Kreisbogens (in Grad).
    **/
   public final void setStartAngle(double startAngle);

   /**
    * Liefert den Startwinkel des Kreisbogens (in Grad).
    **/
   public final double getStartAngleX();

   /**
    * Setzt den Endwinkel des Kreisbogens (in Grad).
    **/
   public final void setEndAngle(double endAngle);

   /**
    * Liefert den Endwinkel des Kreisbogens (in Grad).
    **/
   public final double getEndAngleX();

   /**
    * Legt fest, ob beim Zeichnen des Umrisses auch die beiden Radii ( = Strecken vom Mittelpunkt zur Kreislinie) mitgezeichnet werden
    * sollen.
    **/
   public final void drawRadii(boolean drawRadii);

   /**
    * Erstellt eine Kopie des sector-Objekts und git sie zurück.
    **/
   public final Sector copy();

   /**
    * Gibt genau dann true zurück, wenn die Figur den angegebenen Punkt enthält.
    **/
   public final boolean containsPoint(double x, double y);

   /**
    * Wandelt das Objekt in eine Zeichenkette um und liefert diese zurück.
    **/
   public String toString();

}

/**
 * Ein zählender Semaphor
 **/
public class Semaphore {
   /**
    * Erstellt einen Semaphor mit der angegebenen Zahl von Permits.
    **/
   public Semaphore(int permits);

   /**
    * Gibt die Anzahl an Permits zurück, die in diesem Semaphor aktuell vorhanden ist.
    **/
   public final int availablePermits();

   /**
    * Beschafft ein Permit. Falls keines vorhanden sind wird der Thread blockiert. Der Thread bleibt blockiert bis wieder ein Permit
    * vorhanden ist oder der Thread unterbrochen (interrupted) wird.
    **/
   public void acquire();

   /**
    * Gibt ein Permit frei und führt es dem Semaphor wieder zu.
    **/
   public void release();

}

/**
 * Interface mit Methoden eines Set, d.h. einer Menge, die jedes Element maximal einmal enthält
 **/
public interface Set<E> {
   /**
    * Gibt genau dann true zurück, wenn das Set das Element enthält.
    **/
   public boolean contains(E element);

   /**
    * Gibt genau dann true zurück, wenn das Set alle Elemente der übergebenen Collection enthält.
    **/
   public boolean containsAll(Collection<E> c);

}

/**
 * Die Klasse Shape ist Oberklasse aller graphischen Objekte.
 **/
public class Shape {
   public Shape();

   /**
    * Verschiebt das Grafikobjekt um dx Pixel nach rechts und um dy Pixel nach unten.
    **/
   public final void move(double dx, double dy);

   /**
    * Dreht das Grafikobjekt um den angegebenen Winkel (in Grad!). Drehpunkt ist (centerX, centerY).
    **/
   public final void rotate(double angleInDeg, double centerX, double centerY);

   /**
    * Dreht das Grafikobjekt um den angegebenen Winkel (in Grad!). Der Drehpunkt ist die 'Mitte' des Objekts (abhängig von seiner
    * Form).
    **/
   public final void rotate(double angleInDeg);

   /**
    * Streckt das Grafikobjekt um den angegebenen Faktor. Das Zentrum der Streckung ist der Punkt (centerX, centerY)
    **/
   public final void scale(double factor, double centerX, double centerY);

   /**
    * Streckt das Grafikobjekt auf den angegebenen Faktor. Das Zentrum der Streckung ist die 'Mitte' des Objekts (abhängig von seiner
    * Form).
    **/
   public final void setScale(double newScale);

   /**
    * Streckt das Grafikobjekt um den angegebenen Faktor. Das Zentrum der Streckung ist die 'Mitte' des Objekts (abhängig von seiner
    * Form).
    **/
   public final void scale(double factor);

   /**
    * Spiegelt das Objekt in X-Richtung
    **/
   public final void mirrorX();

   /**
    * Spiegelt das Objekt in Y-Richtung
    **/
   public final void mirrorY();

   /**
    * Setzt die Blickrichtung des graphischen Objekts. Dies ist die Richtung, in die es durch Aufruf der Methode forward bewegt wird. 
    * Bemerkung: die Methode rotate ändert auch die Blickrichtung!
    **/
   public final void defineDirection(double angleInDeg);

   /**
    * Bewegt das Objekt um die angegebene Länge in Richtung seiner Blickrichtung.
    * Bemerkung: Die Blickrichtung kann mit defineDirection gesetzt werden.
    **/
   public final void forward(double distance);

   /**
    * Gibt genau dann true zurück, wenn sich die Bounding Box des Objekts außerhalb des sichtbaren Bereichs befindet.
    **/
   public final boolean isOutsideView();

   /**
    * X-Koordinate des Diagonalenschnittpunkts der BoundingBox des Objekts
    **/
   public final double getCenterX();

   /**
    * Y-Koordinate des Diagonalenschnittpunkts der BoundingBox des Objekts
    **/
   public final double getCenterY();

   /**
    * Richtung des Objekts (in Grad)
    **/
   public final double getAngle();

   /**
    * Dreht das Objekt hin zur angegebenen Richtung (in Grad)
    **/
   public final void setAngle(double newAngle);

   /**
    * Gibt genau dann true zurück, wenn die Figur den angegebenen Punkt enthält.
    **/
   public final boolean containsPoint(double x, double y);

   /**
    * Verschiebt das Grafikobjekt so, dass sich sein 'Mittelpunkt' an den angegebenen Koordinaten befindet.
    **/
   public final void moveTo(double x, double y);

   /**
    * Setzt fest, wo der 'Mittelpunkt' des Objekts liegen soll. Dieser Punkt wird als Drehpunkt der Methode rotate, als Zentrum der
    * Methode Scale und als Referenzpunkt der Methode moveTo benutzt.
    **/
   public final void defineCenter(double x, double y);

   /**
    * Setzt fest, wo der 'Mittelpunkt' des Objekts liegen soll. Dabei bedeutet (XRel/YRel) = (0/0) die linke obere Ecke der Bounding
    * Box des Objekts, (XRel/YRel) = (1/1) die rechte untere Ecke. Defaultwert ist (XRel/YRel) = (0.5/0.5), also der
    * Diagonalenschnittpunkt der Bounding Box. Dieser Punkt wird als Drehpunkt der Methode rotate, als Zentrum der Methode Scale und
    * als Referenzpunkt der Methode moveTo benutzt.
    * 
    * VORSICHT: Diese Methode arbeitet nicht mehr korrekt, wenn das Objekt schon gedreht wurde!
    **/
   public final void defineCenterRelative(double x, double y);

   /**
    * Überzieht das Grafikobjekt mit der angegebenen Farbe. Diese Methode wirkt nur bei denjenigen Grafikobjekten, die die Methode
    * tint unterstützen.
    **/
   public final void tint(int color);

   /**
    * Überzieht das Grafikobjekt mit der angegebenen Farbe. Diese Methode wirkt nur bei denjenigen Grafikobjekten, die die Methode
    * tint unterstützen.
    **/
   public final void tint(String color);

   /**
    * Überzieht das Grafikobjekt mit der angegebenen Farbe. Diese Methode wirkt nur bei denjenigen Grafikobjekten, die die Methode
    * tint unterstützen.
    **/
   public final void tint(Color color);

   /**
    * Gibt die Richtung (top, right, bottom oder left) zurück, in der das graphische Objekt relativ zum übergebenen graphischen Objekt
    * steht.
    **/
   public final Direction directionRelativeTo(Shape otherShape);

   /**
    * Rückt das Objekt entlang der letzten durch Aufruf der Methode move() vorgegebenen Richtung zurück, bis es das übergebene Objekt
    * gerade noch (keepColliding == true) bzw. gerade nicht mehr (keepColliding == false) berührt.
    **/
   public final void moveBackFrom(Shape otherShape, boolean keepColliding);

   /**
    * Setzt den Standardwert für das Attribut 'visible'. Dieser wird nachfolgend immer dann verwendet, wenn ein neues grafisches
    * Objekt instanziert wird.
    **/
   public static void setDefaultVisibility(boolean isVisible);

   /**
    * Macht das Grafikobjekt sichtbar (visible == true) bzw. unsichtbar (visible == false).
    **/
   public final void setVisible(boolean isVisible);

   /**
    * Macht das Grafikobjekt sichtbar (visible == true) bzw. unsichtbar (visible == false).
    **/
   public final boolean isVisible();

   /**
    * setStatic(true) hat zur Folge, dass die Ansicht des Objekts durch Transformationen des World-Objekts nicht verändert wird.
    **/
   public final void setStatic(boolean isStatic);

   /**
    * Setzt das Grafikobjekt vor alle anderen innerhalb der Gruppe.
    **/
   public final void bringToFront();

   /**
    * Setzt das Grafikobjekt hinter alle anderen innerhalb der Gruppe.
    **/
   public final void sendToBack();

   /**
    * Gibt genau dann true zurück, wenn die Figur mit der anderen Figur überlappt.
    **/
   public final boolean collidesWith(Shape otherShape);

   /**
    * Gibt genau dann true zurück, wenn die Figur mit irgendeiner anderen Figur überlappt.
    **/
   public final boolean collidesWithAnyShape();

   /**
    * Gibt genau dann true zurück, wenn die Figur mit irgendeiner anderen Figur mit der angegebenen Füllfarbe überlappt.
    **/
   public final boolean collidesWithFillColor(int color);

   /**
    * Gibt genau dann true zurück, wenn die Figur mit irgendeiner anderen Figur mit der angegebenen Füllfarbe überlappt.
    **/
   public final boolean collidesWithFillColor(String color);

   /**
    * Gibt genau dann true zurück, wenn die Figur mit irgendeiner anderen Figur mit der angegebenen Füllfarbe überlappt.
    **/
   public final boolean collidesWithFillColor(Color color);

   /**
    * Falls dieses Grafikobjekt gerade mindestens ein Sprite mit dem übergebenen Bildindex (-1 bedeutet: mit irgendeinem BildIndex)
    * berührt, wird das erste dieser Sprites zurückgegeben.
    **/
   public final Sprite getFirstCollidingSprite(int imageIndex);

   /**
    * Gibt alle Elemente der Group zurück, die mit diesem graphischen Objekt kollidieren.
    **/
   public final <T> T[] getCollidingShapes(Group<T> group);

   /**
    * Wird aufgerufen, wenn sich der Mauspfeil über dem Objekt befindet und der Benutzer eine Maustaste loslässt.
    **/
   public void onMouseUp(double x, double y, int button);

   /**
    * Wird aufgerufen, wenn sich der Mauspfeil über dem Objekt befindet und der Benutzer eine Maustaste drückt.
    **/
   public void onMouseDown(double x, double y, int button);

   /**
    * Wird aufgerufen, wenn der Mauspfeil das Objekt betritt.
    **/
   public void onMouseEnter(double x, double y);

   /**
    * Wird aufgerufen, wenn der Mauspfeil das Objekt verlässt.
    **/
   public void onMouseLeave(double x, double y);

   /**
    * Wird aufgerufen, wenn sich der Mauspfeil über dem Objekt befindet und der Benutzer die Maus bewegt.
    **/
   public void onMouseMove(double x, double y);

   /**
    * Sorgt dafür, dass ab jetzt JEDE Bewegung des Mauszeigers (auch wenn sich dieser außerhalb des Objekts befindet) ein
    * MouseMove-Ereignis für dieses Objekt auslöst. -> Praktisch zur Umsetzung des "Ziehens" von Objekten mit der Maus!
    **/
   public void startTrackingEveryMouseMovement();

   /**
    * Sorgt dafür, dass ab jetzt JEDE Bewegung des Mauszeigers (auch wenn sich dieser außerhalb des Objekts befindet) ein
    * MouseMove-Ereignis für dieses Objekt auslöst. -> Praktisch zur Umsetzung des "Ziehens" von Objekten mit der Maus!
    **/
   public void stopTrackingEveryMouseMovement();

   /**
    * Erstellt eine Kopie des Grafikobjekts und gibt sie zurück.
    **/
   public Shape copy();

   /**
    * Gibt das aktuelle World-Objekt zurück.
    **/
   public final World getWorld();

}

public class Short {
   public static final int MAX_VALUE;
   public static final int MIN_VALUE;
   public Short(short d);

   public final double doubleValue();

   public final float floatValue();

   public final int intValue();

   public final long longValue();

   public int compareTo(Short otherShort);

   public static short parseShort(String s);

   public static short parseShort(String sr, int radix);

   public static Short valueOf(short i);

   public static Short valueOf(String s);

   public static Short valueOf(String s, short radix);

}

/**
 * Klasse mit statischen Methoden und statischen Konstanten zur Ausgabe von Sound
 **/
public class Sound {
   /**
    * nahe Explosion mit herabfallenden Trümmern
    **/
   public static String nearby_explosion_with_debris;
   /**
    * nahe Explosion
    **/
   public static String nearby_explosion;
   /**
    * fernes Geräusch einer Bombe
    **/
   public static String far_bomb;
   /**
    * einzelner Kanonendonner
    **/
   public static String cannon_boom;
   /**
    * ferne Explosion
    **/
   public static String far_explosion;
   /**
    * Laserschuss (oder was man dafür hält...)
    **/
   public static String laser_shoot;
   /**
    * kurzes Klingeln (wie bei alter Landenkasse)
    **/
   public static String short_bell;
   /**
    * Flammenwerfer
    **/
   public static String flamethrower;
   /**
    * Geräusch beim Sandschaufeln
    **/
   public static String digging;
   /**
    * kurzes Geräusch beim Sandschaufeln
    **/
   public static String short_digging;
   /**
    * Schussgeräusch
    **/
   public static String shoot;
   /**
    * ein kurzer Schuss
    **/
   public static String short_shoot;
   /**
    * ein Schritt
    **/
   public static String step;
   /**
    * Geräusch eines Steins, der auf einen zweiten fällt
    **/
   public static String boulder;
   /**
    * Tiefer Pong-Ton
    **/
   public static String pong_d;
   /**
    * Hoher Pong-Ton
    **/
   public static String pong_f;
   /**
    * Spielt einen Sound ab. Die Möglichen Sounds sind als statische Variablen der Klasse Sound hinterlegt. Tippe als Parameter also
    * Sound gefolgt von einem Punkt ein, um eine Auswahl zu sehen!
    **/
   public static void playSound(String sound);

   /**
    * Gibt die aktuelle Mikrofonlautstärke zurück. Beim ersten Aufruf muss der Benutzer dem Browser die Erlaubnis zur Benutzung des
    * Mikrofons geben. Solange dies noch nicht erfolgt ist, gibt die Funktion den Wert -1 zurück.
    **/
   public static double getVolume();

}

public class Sphere3d {
   public Sphere3d(double radius, int widthSegments, int heightSegments, double phiStart, double phiLength, double thetastart, double thetaLength);

   public Sphere3d(double radius, int widthSegments, int heightSegments);

   public Sphere3d(double radius);

   public Sphere3d();

}

/**
 * Ein Sprite ist eine kleine Pixelgrafik, die verschoben, gedreht und skaliert werden kann. Zudem besitzt es Methoden zum Erkennen
 * von Kollisionen mit anderen grafischen Objekten.
 **/
public class Sprite {
   /**
    * Instanziert ein neues Sprite und stellt es an der Position (x, y) dar (== Diagonalenschnittpunkt der Boundingbox). SpriteLibrary
    * ist ein Aufzählungstyp (enum). Gib einfach SpriteLibraryEntry gefolgt von einem Punkt ein, dann erhältst Du ein Auswahl von
    * Bildern. Einen Überblick über die Bilder bekommst Du auch über den Menüpunkt Hilfe->Sprite-Bilderübersicht.
    **/
   public Sprite(double x, double y, SpriteLibrary spriteLibraryEntry, int index, ScaleMode scalemode);

   /**
    * Instanziert ein neues Sprite und stellt es an der Position (x, y) dar (== Diagonalenschnittpunkt der Boundingbox). SpriteLibrary
    * ist ein Aufzählungstyp (enum). Gib einfach SpriteLibraryEntry gefolgt von einem Punkt ein, dann erhältst Du ein Auswahl von
    * Bildern. Einen Überblick über die Bilder bekommst Du auch über den Menüpunkt Hilfe->Sprite-Bilderübersicht.
    **/
   public Sprite(double x, double y, SpriteLibrary spriteLibraryEntry, int index);

   /**
    * Instanziert ein neues Sprite und stellt es an der Position (x, y) dar (== Diagonalenschnittpunkt der Boundingbox). SpriteLibrary
    * ist ein Aufzählungstyp (enum). Gib einfach SpriteLibraryEntry gefolgt von einem Punkt ein, dann erhältst Du ein Auswahl von
    * Bildern. Einen Überblick über die Bilder bekommst Du auch über den Menüpunkt Hilfe->Sprite-Bilderübersicht.
    **/
   public Sprite(double x, double y, SpriteLibrary spriteLibraryEntry);

   /**
    * Zeichnet das graphische Objekt (shape) in eine Bitmap und macht daraus ein Sprite. Dieses wird an der Position (0, 0)
    * dargestellt.
    **/
   public Sprite(Shape shape, ScaleMode scalemode);

   /**
    * Zeichnet das graphische Objekt (shape) in eine Bitmap und macht daraus ein Sprite. Dieses wird an der Position (0, 0)
    * dargestellt.
    **/
   public Sprite(Shape shape);

   /**
    * Ändert das Bild des Sprites. SpriteLibraryEntry ist ein Auzählungstyp (enum). Gib einfach SpriteLibraryEntry gefolgt von einem
    * Punkt ein, dann erhältst Du ein Auswahl von Bildern. Einen Überblick über die Bilder bekommst Du auch über den Menüpunkt
    * Hilfe->Sprite-Bilderübersicht.
    **/
   public void setImage(SpriteLibrary spriteLibrary, int imageIndex);

   /**
    * Ändert den Bildindex des Sprites, so dass ein anderes Bild der SpriteLibrary dargestellt wird.
    **/
   public void setImageIndex(int imageIndex);

   /**
    * Spielt eine Animation ab.
    **/
   public void playAnimation(int[] imageIndexArray, RepeatType repeatType, int imagesPerSecond);

   /**
    * Spielt eine Animation ab.
    **/
   public void playAnimation(int fromIndex, int toIndex, RepeatType repeatType, int imagesPerSecond);

   /**
    * Stoppt die gerade laufende Animation
    **/
   public void stopAnimation();

   /**
    * Pausiert die gerade laufende Animation
    **/
   public void pauseAnimation();

   /**
    * Fährt mit einer pausierten Animation wieder fort.
    **/
   public void resumeAnimation();

   /**
    * Streckt und verschiebt das Sprite so, dass es die gesamte Zeichenfläche überdeckt.
    **/
   public void setAsBackgroundImage();

   /**
    * Setzt die Durchsichtigkeit. 0.0 bedeutet vollkommen durchsichtig, 1.0 bedeutet vollkommen undurchsichtig.
    **/
   public void setAlpha(double alphaValue);

   /**
    * Erstellt eine Kopie des Sprite-Objekts und git sie zurück.
    **/
   public Sprite copy();

   /**
    * Gibt die Breite des Sprites in Pixeln zurück.
    **/
   public double getWidth();

   /**
    * Gibt die Höhe des Sprites in Pixeln zurück.
    **/
   public double getHeight();

   /**
    * Gibt den Index des Bildes innerhalb der Sprite-Library zurück.
    **/
   public int getImageIndex();

   /**
    * Fügt das identische Bild nach rechts und unten kachelartig ('tile'!) so oft hinzu, bis die angegebene Breite erreicht ist. 
    * TIPP: Mit der Methode getTileImage() erhält man ein Tile-Objekt, dessen Methoden move, scale, mirrorX und mirrorY sich
    * gleichzeitig auf jede einzelne Kachel auswirken.
    **/
   public void makeTiling(double width, double height);

   /**
    * Fügt das identische Bild nach rechts und unten kachelartig ('tile'!) so oft hinzu, bis die angegebene Breite erreicht ist. GapX
    * und GapY sind die Abstände, die zwischen den einzelnen Kacheln eingehalten werden. 
    * TIPP: Mit der Methode getTileImage() erhält man ein Tile-Objekt, dessen Methoden move, scale, mirrorX und mirrorY sich
    * gleichzeitig auf jede einzelne Kachel auswirken.
    **/
   public void makeTiling(double width, double height, double gapX, double gapY);

   /**
    * Nachdem das Sprite mittels der Methode 'makeTiling' zum TileSprite gemacht wurde, kann wirken die Methoden move, scale und
    * rotate immer auf den ganzen gekachelten Bereich. Will man das verfielfachte Bild ändern, so bekommt man über diese Methode das
    * Sprite-Objekt, das diesem Bild entspricht. Ruft man für dieses Objekt die Methoden move, rotate oder scale auf, so wirken sie
    * auf jede der einzelnen Kacheln.
    **/
   public TileImage getTileImage();

}

public class Sprite3d {
   public Sprite3d(double width, SpriteLibrary spriteLibrary, int index);

   public void move(double x, double y, double z);

   public void moveTo(double x, double y, double z);

   public double getX();

   public double getY();

   public double getZ();

   public void setColor(int color);

   public void setAlpha(double alpha);

   public void scaleX(double angleDeg);

   public void scaleY(double angleDeg);

   public void scaleZ(double angleDeg);

   public void scale(Vector3 v);

   public void scale(double d);

   public void rotateX(double angleDeg);

   public void rotateY(double angleDeg);

   public void rotateZ(double angleDeg);

   public void rotate(double angleDeg);

   public final void move(Vector3 v);

   public void moveTo(double x, double y, double z);

   public final void moveTo(Vector3 p);

   public final void scale(double d);

   public void destroy();

}

/**
 * Aufzählung der Sprite-Grafikbibliotheken
 **/
public enum SpriteLibrary {
   Ship_1, Werkzeug, Minesweeper, Sleepy_Blocks, Bird, Space_Shooter_1, Space_Shooter_2, Particles, Soko, PMan, Breakin, Boardgames, Plattforms, TowerDefense, Characters_1, Background, Frogger, robot, standard_textures, pixelmon, Sneaker, Kara, Hamster, Explosion_1, Boulders;

   public static SpriteLibrary[] values();

   public static SpriteLibrary valueOf(String name);

}

/**
 * Stack (Stapelspeicher/Kellerspeicher)
 **/
public class Stack<E> {
   /**
    * Erstellt ein neues, leeres Stack-Objekt.
    **/
   public Stack();

   /**
    * Legt ein Element 'oben' auf den Stack.
    **/
   public E push(E element);

   /**
    * Nimmt ein Element 'von oben' vom Stack.
    **/
   public E pop();

   /**
    * Gibt das oberste Elements des Stacks zurück ohne es vom Stack zu nehmen.
    **/
   public E peek();

   /**
    * Gibt genau dann true zurück, wenn der Stack leer ist.
    **/
   public boolean empty();

   /**
    * Sucht das Element vom 'Boden' des Stack aus und gibt seinen Index zurück, falls das Element gefunden wurde. Das unterste Element
    * hat Index 0. Falls das Element nicht gefunden wurde, wird -1 zurückgegeben.
    **/
   public int search(E element);

}

public enum State {
   new, running, stopped_at_breakpoint, runnable, waiting, timed_waiting, terminated;

   public static State[] values();

   public static State valueOf(String name);

}

public interface Stream<T> {
   public Object[] toArray();

   public long count();

   public void forEach(Consumer<?> action);

   public Stream<T> filter(Predicate<?> predicate);

   public <R> Stream<R> map(Function<?, R> mapper);

}

/**
 * Ein String ist eine Zeichenkette.
 **/
public class String {
   /**
    * Erzeugt ein neues, leeres String-Objekt.
    **/
   public String();

   /**
    * Erzeugt ein String-Objekt auf Grundlage des übergebenen.
    **/
   public String(String original);

   /**
    * Erzeugt ein String-Objekt auf Grundlage des übergebenen char[].
    **/
   public String(char[] value);

   /**
    * Wandelt das Objekt in eine Zeichenkette um und liefert diese zurück.
    **/
   public final String toString();

   /**
    * Gibt die Länge des Strings (== Anzahl an Zeichen) zurück.
    **/
   public final int length();

   /**
    * Gib den Index innerhalb dieses Strings zurück, ab dem der übergebene String zum ersten Mal auftritt. Gibt -1 zurück, falls
    * dieser nicht im String enthalten ist.
    **/
   public final int indexOf(String str);

   /**
    * Gib den Index innerhalb dieses Strings zurück, ab dem der übergebene String NACH fromIndex zum ersten Mal auftritt. Gibt -1
    * zurück, falls dieser NACH fromIndex nicht im String enthalten ist.
    **/
   public final int indexOf(String str, int fromIndex);

   /**
    * Gib den Index innerhalb dieses Strings zurück, ab dem das übergebene Zeichen zum ersten Mal auftritt. Gibt -1 zurück, falls
    * dieses nicht im String enthalten ist.
    **/
   public final int indexOf(char c);

   /**
    * Gib den Index innerhalb dieses Strings zurück, ab dem das übergebene Zeichen NACH fromIndex zum ersten Mal auftritt. Gibt -1
    * zurück, falls dieses NACH fromIndex nicht im String enthalten ist.
    **/
   public final int indexOf(char c, int fromIndex);

   /**
    * Gibt das Zeichen an der angegebenen Position zurück. Das erste Zeichen im String hat Position 0.
    **/
   public final char charAt(int index);

   /**
    * Vergleicht das Objekt mit dem übergebenen Objekt. Liefert eine negative Zahl zurück, wenn das Objekt 'kleiner' ist als das
    * übergebene, eine positive, falls es größer ist und 0, wenn beide Objekte gleich sind.
    **/
   public final int compareTo(String otherString);

   /**
    * Vergleicht die beiden Zeichenketten lexikalisch ohne Berücksichtigung von Klein- und Großschreibung und gibt entsprechend -1, 0
    * oder 1 zurück.
    **/
   public final int compareToIgnoreCase(String otherString);

   /**
    * Gibt einen String zurück, der entsteht, indem man den übergebenen String hinter diesen hängt. Verändert den String dabei aber
    * nicht.
    **/
   public final String concat(String otherString);

   /**
    * Gibt genau dann true zurück, wenn der String den übergebenen String enthält.
    **/
   public final boolean contains(String otherString);

   /**
    * Gibt genau dann true zurück, wenn der String mit dem übergebenen String endet.
    **/
   public final boolean endsWith(String otherString);

   /**
    * Gibt genau dann true zurück, wenn der String mit dem übergebenen String beginnt.
    **/
   public final boolean startsWith(String otherString);

   /**
    * Gibt genau dann true zurück, wenn das Objekt und das übergebene Objekt 'gleich' sind.
    **/
   public boolean equals(Object otherObject);

   /**
    * Gibt genau dann true zurück, wenn das Objekt und das übergebene Objekt 'gleich' sind.
    **/
   public boolean equals(String otherObject);

   /**
    * Gibt genau dann true zurück, wenn der übergebene String diesem String bis auf Klein- und Großschreibung gleicht.
    **/
   public final boolean equalsIgnoreCase(String otherString);

   /**
    * Gibt genau dann true zurück, wenn der String leer ist, sich also keine Zeichen darin befinden. Das ist wiederum genau dann der
    * Fall, wenn die Länge des Strings 0 beträgt.
    **/
   public final boolean isEmpty();

   /**
    * Gib den Index innerhalb dieses Strings zurück, ab dem der übergebene String zum letzten Mal auftritt. Gibt -1 zurück, falls
    * dieser nicht im String enthalten ist.
    **/
   public final int lastIndexOf(String str);

   /**
    * Gib den Index innerhalb dieses Strings zurück, ab dem der übergebene String VOR fromIndex zum letzten Mal auftritt. Gibt -1
    * zurück, falls dieser VOR fromIndex nicht im String enthalten ist.
    **/
   public final int lastIndexOf(String str, int fromIndex);

   /**
    * Gib den Index innerhalb dieses Strings zurück, ab dem das übergebene Zeichen zum letzten Mal auftritt. Gibt -1 zurück, falls
    * dieses nicht im String enthalten ist.
    **/
   public final int lastIndexOf(char c);

   /**
    * Gib den Index innerhalb dieses Strings zurück, ab dem das übergebene Zeichen VOR fromIndex zum letzten Mal auftritt. Gibt -1
    * zurück, falls dieses VOR fromIndex nicht im String enthalten ist.
    **/
   public final int lastIndexOf(char c, int fromIndex);

   /**
    * Gibt einen String zurück, der den String in Kleinschreibung enthält.
    **/
   public final String toLowerCase();

   /**
    * Gibt einen String zurück, der den String in Großschreibung enthält.
    **/
   public final String toUpperCase();

   /**
    * Gibt den Teilstring ab der übergebenen Position zurück. Position 0 ist der Beginn des Strings.
    **/
   public final String substring(int beginIndex);

   /**
    * Gibt den Teilstring zwischen den beiden übergebenen Positionen zurück. Position 0 ist der Beginn des Strings.
    **/
   public final String substring(int beginIndex, int endIndex);

   /**
    * Gibt den String zurück, der entsteht, wenn man an Beginn und Ende alle unsichtbaren Zeichen (d.h. Leerzeichen, tabs und
    * Zeilenumbrüche) entfernt.
    **/
   public final String trim();

   /**
    * Ersetzt alle Vorkommen von **target** durch **replacement** und gibt die entstandene Zeichenkette zurück. Die Zeichenkette
    * selbst wird nicht verändert.
    **/
   public final String replace(String target, String replacement);

   /**
    * Durchsucht den String mit dem regulären Ausdruck (regex) und ersetzt **alle** Fundstellen durch **replacement**.
    **/
   public final String replaceAll(String regex, String replacement);

   /**
    * Gibt genau dann true zurück, wenn der Wert der Zeichenkette dem regulären Ausdruck (regex) entspricht.
    **/
   public final String matches(String regex);

   /**
    * Durchsucht den String mit dem regulären Ausdruck (regex) und ersetzt **die erste** Fundstelle durch **replacement**.
    **/
   public final String replaceFirst(String regex, String replacement);

   /**
    * Teilt die Zeichenkette an den Stellen, die durch den regulären Ausdruck (regex) definiert sind, in Teile auf. Die Fundstellen
    * des regex werden dabei weggelassen. Gibt die Teile als String-Array zurück.
    **/
   public final String[] split(String regex);

   /**
    * Gibt den Hashcode des String zurück. Er wird wie folgt berechnet: s[0]*31^(n-1) + s[1]*31^(n-2) + ... + s[n-1]. Dabei ist s[i]
    * das i-te Zeichen des Strings.
    **/
   public final int hashCode();

   /**
    * Wandelt den String in ein char[] um.
    **/
   public final char[] toCharArray();

   /**
    * Wandelt den Parameterwert in eine Zeichenkette um.
    **/
   public static String valueOf(boolean b);

   /**
    * Wandelt den Parameterwert in eine Zeichenkette um.
    **/
   public static String valueOf(char c);

   /**
    * Wandelt den Parameterwert in eine Zeichenkette um.
    **/
   public static String valueOf(int i);

   /**
    * Wandelt den Parameterwert in eine Zeichenkette um.
    **/
   public static String valueOf(long l);

   /**
    * Wandelt den Parameterwert in eine Zeichenkette um.
    **/
   public static String valueOf(float f);

   /**
    * Wandelt den Parameterwert in eine Zeichenkette um.
    **/
   public static String valueOf(double d);

   /**
    * Wandelt den Parameterwert in eine Zeichenkette um.
    **/
   public static String valueOf(char[] data);

   /**
    * Wandelt den Parameterwert in eine Zeichenkette um.
    **/
   public static String valueOf(Object o);

}

/**
 * Klasse mit statischen Methoden für Systemfunktionen.
 **/
public class System {
   /**
    * PrintStream-Objekt, mit dem Text ausgegeben werden kann.
    **/
   public static PrintStream out;
   /**
    * Beendet das Programm und gibt den übergebenen Wert in der Konsole aus.
    **/
   public static void exit(int status);

   /**
    * Gibt die Anzahl der Millisekunden, die seit dem 01.01.1970 00:00:00 UTC vergangen sind, zurück.
    **/
   public static int currentTimeMillis();

   /**
    * Gibt die Anzahl an Nanosekunden seit einem nicht näher definierten Startzeitpunkt zurück.
    **/
   public static long nanoTime();

}

public class SystemStream<T> {
   public Object[] toArray();

   public long count();

   public void forEach(Consumer<?> action);

   public Stream<T> filter(Predicate<?> predicate);

   public <R> Stream<R> map(Function<?, R> mapper);

}

/**
 * Klasse mit statischen Methoden für Systemfunktionen, z.B. Löschen der Ausgabe, Registrieren eines Tastaturlisteners usw.
 **/
public class SystemTools {
   /**
    * Löscht den Textausgabe-Bildschirm
    **/
   public static void clearScreen();

   /**
    * Setzt die Ausführungsgeschwindigkeit. Der Parameter speed wir in Steps/Sekunde angegeben. Eine negative Zahl bedeutet:
    * 'maximal'.
    **/
   public static void setSpeed(int stepsPerSecond);

   /**
    * Gibt die Ausführungsgeschwindigkeit in Steps pro Sekunde zurück.
    **/
   public static int getSpeed();

   /**
    * Pausiert das Programm für die angegebene Zeit in ms.
    **/
   public static void pause(int milliseconds);

   /**
    * Gibt die Anzahl der seit dem Start des Programms ausgeführten Steps (== Programmschritte) zurück.
    **/
   public static int getStepCount();

   /**
    * Fügt einen KeyListener hinzu, dessen Methode keyTyped immer dann aufgerufen wird, wenn eine Taste gedrückt und anschließend
    * losgelassen wird.
    **/
   public static void addKeyListener(KeyListener keyListener);

}

/**
 * Text, der innerhalb der Grafikausgabe dargestellt werden kann
 **/
public class Text {
   /**
    * Instanziert ein neues Textobjekt. Der Textanker (default: links oben) liegt bei (0, 0).
    **/
   public Text();

   /**
    * Instanziert ein neues Textobjekt. (x, y) sind die Koordinaten des Textankers (default: links oben), fontsize die Höhe des Textes
    * in Pixeln.
    **/
   public Text(double x, double y, double fontSize, String text);

   /**
    * Instanziert ein neues Textobjekt. (x, y) sind die Koordinaten des Textankers (default: links oben), fontsize die Höhe des Textes
    * in Pixeln.
    **/
   public Text(double x, double y, double fontSize, String text, String fontFamily);

   /**
    * Instanziert ein neues Textobjekt. (x, y) sind die Koordinaten des Textankers (default: links oben), fontsize die Höhe des Textes
    * in Pixeln.
    **/
   public Text(double x, double y, double fontSize, double text);

   /**
    * Instanziert ein neues Textobjekt. (x, y) sind die Koordinaten des Textankers (default: links oben), fontsize die Höhe des Textes
    * in Pixeln.
    **/
   public Text(double x, double y, double fontSize, double text, String fontFamily);

   /**
    * Setzt die Schriftgröße des Textes (Einheit: Pixel).
    **/
   public void setFontsize(double fontsize);

   /**
    * Setzt den Text dieses graphischen Text-Objektes.
    **/
   public void setText(String text);

   /**
    * Setzt den Text dieses graphischen Text-Objektes.
    **/
   public void setText(double text);

   /**
    * Setzt die Ausrichtung des Textes, z.B. Alignment.center, Alignment.right.
    **/
   public void setAlignment(Alignment alignment);

   /**
    * Setzt den Stil des Textes: isBold (Fettschrift) und isItalic (Schrägschrift).
    **/
   public void setStyle(boolean bold, boolean italic);

   /**
    * Gibt die Schriftgröße zurück.
    **/
   public double getFontsize();

   /**
    * Gibt den Textinhalt zurück.
    **/
   public String getText();

   /**
    * Gibt die Breite des Textes zurück.
    **/
   public double getWidth();

   /**
    * Gibt die Höhe des Textes zurück.
    **/
   public double getHeight();

   /**
    * Verschiebt das Grafikobjekt so, dass sich sein 'Mittelpunkt' an den angegebenen Koordinaten befindet.
    **/
   public final void moveTo(double x, double y);

   /**
    * Erstellt eine Kopie dieses Text-Objekts
    **/
   public final Text copy();

   /**
    * Wandelt das Objekt in eine Zeichenkette um und liefert diese zurück.
    **/
   public String toString();

}

/**
 * Textfeld, das innerhalb der Grafikausgabe dargestellt werden kann
 **/
public class TextField {
   /**
    * Instanziert ein neues TextField-Objekt. (x, y) sind die Koordinaten der linken oberen Ecke, fontsize die Höhe des Textes in
    * Pixeln.
    **/
   public TextField(double x, double y, double width, double fontsize, String caption);

   /**
    * Instanziert ein neues TextField-Objekt. (x, y) sind die Koordinaten der linken oberen Ecke, fontsize die Höhe des Textes in
    * Pixeln.
    **/
   public TextField(double x, double y, double width, double fontsize, String caption, String fontFamily);

   /**
    * Erzeugt eine Kopie des Textfield-Objekts
    **/
   public TextField copy();

   /**
    * 'Setzt den Innenabstand (padding) des Textes zum umgebenden Rechteck.
    **/
   public void setPadding(double padding);

}

/**
 * Texturen, die mit den 3d-Klassen (z.B. Sphere3d, Box3d) genutzt werden können, z.B. new Spere3d().setTexture(Textures.earth)
 **/
public enum Texture {
   earth2k, jupiter2k, mars2k, mercury2k, moon2k, neptune2k, saturn2k, stars2k, stars8k, stars_milky_way2k, stars_milky_way8k, sun2k, uranus2k, venus_atmosphere2k;

   public static Texture[] values();

   public static Texture valueOf(String name);

}

/**
 * Ein Thread ist ein 'Ausführungsstrang' in einem Programm. Die Online IDE ermöglicht die gleichzeitige Ausführung mehrerer
 * Threads.
 **/
public class Thread {
   /**
    * Erstellt ein neues Thread-Objekt, startet den Thread aber noch nicht.
    **/
   public Thread();

   /**
    * Erstellt ein neues Thread-Objekt. Wird der Thread gestartet, so wird die run()-Methode des übergebenen Runnable-Objekts
    * ausgeführt.
    **/
   public Thread(Runnable runnable);

   /**
    * Erstellt ein neues Thread-Objekt. Wird der Thread gestartet, so wird die run()-Methode des übergebenen Runnable-Objekts
    * ausgeführt.
    **/
   public Thread(Runnable runnable, String name);

   /**
    * Erstellt ein neues Thread-Objekt, startet den Thread aber noch nicht.
    **/
   public Thread(String name);

   /**
    * Gibt den state des threads zurück.
    **/
   public State getState();

   /**
    * Führt die run()-Methode des bei diesem Thread gespeicherten Runnable-Objekts im AKTUELLEN thread aus. Die Wirkung ist dieselbe,
    * als würde man die run()-Methode des Runnable-Objekts einfach aufrufen.
    **/
   public void run();

   /**
    * Führt die run()-Methode des bei diesem Thread gespeicherten Runnable-Objekts nebenläufig (parallel) zum aktuellen Thread aus.
    **/
   public void start();

   /**
    * Wartet bis der Thread beendet (terminated) ist.
    **/
   public void join();

   /**
    * Wartet bis der Thread beendet (terminated) ist, längstens aber die übergebene Zahl an Millisekunden.
    **/
   public void join(int milliseconds);

   /**
    * Gibt den Namen des Threads zurück.
    **/
   public String getName();

   /**
    * Ändert den Namen dieses Threads.
    **/
   public void setName(String name);

   /**
    * Setzt die gewünschte Ausführungsgeschwindigkeit des Threads in Schritten/Sekunde. Werte <= 0 bewirken die Ausführung mit
    * maximaler Geschwidigkeit.
    **/
   public void setSpeed(int maxStepsPerSecond);

   /**
    * Bewirkt, dass der gerade ausgeführte Thread für die angegebene Zeit (in Millisekunden) pausiert (schläft). Die genaue Länge des
    * 'Schlafes' hängt von der Genauigkeit des Laufzeitsystems und vom Scheduler ab.
    **/
   public static void sleep(int milliseconds);

   /**
    * Gibt das Thread-Objekt für den gerade ausgeführten Thread zurück.
    **/
   public static Thread currentThread();

}

public class Throwable {
   public Throwable();

   public Throwable(String message);

   public Throwable(Throwable cause);

   public Throwable(String message, Throwable cause);

   public String toString();

   public String getMessage();

}

/**
 * Eine Kachel in einem Sprite, das mithilfe der Methode makeTiling zu einer Kachelfläche gemacht wurde.
 **/
public class TileImage {
   /**
    * Verschiebt das Grafikobjekt um dx Pixel nach rechts und um dy Pixel nach unten.
    **/
   public void move(double x, double y);

   /**
    * Streckt das Grafikobjekt um den angegebenen Faktor. Das Zentrum der Streckung ist der 'Mittelpunkt' des Objekts.
    **/
   public void scale(double factor);

   /**
    * Spiegelt das Objekt in X-Richtung.
    **/
   public void mirrorX();

   /**
    * Spiegelt das Objekt in Y-Richtung.
    **/
   public void mirrorY();

}

/**
 * Timer Klasse zur periodischen Ausführung von Methoden
 **/
public class Timer {
   /**
    * Fügt ein neues Runnable-Objekt hinzu und ruft dessen tick-Methode immer wieder auf.
    **/
   public static void repeat(Runnable runnable, int deltaTimeMilliseconds);

   /**
    * Führt die übergebene Methode nach dt millisekunden ein Mal aus.
    **/
   public static void executeLater(Runnable runnable, int deltaTimeMilliseconds);

   /**
    * Fügt ein neues Runnable-Objekt hinzu und ruft dessen tick-Methode immer wieder auf.
    **/
   public void repeat(Runnable runnable, int deltaTimeMilliseconds);

   /**
    * Hält den Timer an. Er kann später mit der Methode restart() wieder gestartet werden.
    **/
   public void pause();

   /**
    * Startet den Timer erneut, nachdem er mit pause() pausiert wurde.
    **/
   public void restart();

}

public class Torus3d {
   public Torus3d(double radius, double tube, int radialSegments, int tubularSegments, double arc);

   public Torus3d(double radius, double tube, int radialSegments, int tubularSegments);

   public Torus3d();

}

/**
 * Dreieck
 **/
public class Triangle {
   /**
    * Erstellt ein Dreieck mit den Eckpunkten (0,0), (100, 0) und (0, 100).
    **/
   public Triangle();

   /**
    * Erstellt ein Dreieck mit den gegebenen drei Eckpunkten.
    **/
   public Triangle(double x1, double y1, double x2, double y2, double x3, double y3);

   /**
    * Erstellt eine Kopie des Dreiecks.
    **/
   public final Triangle copy();

}

/**
 * Turtle-Klasse zum Zeichnen von Streckenzügen oder gefüllten Figuren. Wichtig sind vor allem die Methoden forward(double length)
 * und turn(double angleDeg), die die Turtle nach vorne bewegen bzw. ihre Blickrichtung ändern.
 **/
public class Turtle {
   /**
    * Instanziert ein neues Turtle-Objekt ohne Punkte. Die Turtle blickt anfangs nach rechts. Am Ende des Streckenzugs wird eine
    * 'Schildkröte' (kleines Dreieck) gezeichnet.
    **/
   public Turtle();

   /**
    * Instanziert ein neues Turtle-Objekt ohne Punkte. (x, y) is die Startposition der Turtle. Die Turtle blickt anfangs nach rechts.
    * Am Ende des Streckenzugs wird eine 'Schildkröte' (kleines Dreieck) gezeichnet.
    **/
   public Turtle(double x, double y);

   /**
    * Instanziert ein neues Turtle-Objekt ohne Punkte. (x, y) is die Startposition der Turtle. Die Turtle blickt anfangs nach rechts.
    * Falls showTurtle == true wird am Ende des Streckenzugs eine 'Schildkröte' (kleines Dreieck) gezeichnet.
    **/
   public Turtle(double x, double y, boolean showTurtle);

   /**
    * Weist die Turtle an, die angegebene Länge vorwärts zu gehen. Ihr zurückgelegter Weg wird als gerade Strecke mit der aktuellen
    * BorderColor gezeichnet. Mit setBorderColor(null) bewirkst Du, dass ein Stück ihres Weges nicht gezeichnet wird.
    **/
   public final void forward(double length);

   /**
    * Bewirkt, dass sich die Turtle um den angegebenen Winkel (in Grad!) dreht, d.h. ihre Blickrichtung ändert. Ein positiver Winkel
    * bewirkt eine Drehung gegen den Uhrzeigersinn. Diese Methode wirkt sich NICHT auf die bisher gezeichneten Strecken aus. Willst Du
    * alles bisher Gezeichnete inklusive Turtle drehen, so nutze die Methode rotate.
    **/
   public final void turn(double angleInDeg);

   /**
    * Bewirkt, dass die Turtle beim Gehen ab jetzt nicht mehr zeichnet.
    **/
   public final void penUp();

   /**
    * Bewirkt, dass die Turtle beim Gehen ab jetzt wieder zeichnet.
    **/
   public final void penDown();

   /**
    * closeAndFill == true bewirkt, dass das von der Turtlezeichnung umschlossene Gebiet gefüllt wird.
    **/
   public final void closeAndFill(boolean closeAndFill);

   /**
    * showTurtle == true bewirkt, dass am Ort der Turtle ein rotes Dreieck gezeichnet wird.
    **/
   public final void showTurtle(boolean showTurtle);

   /**
    * Löscht alle bis jetzt mit der Turtle gezeichneten Strecken.
    **/
   public final void clear();

   /**
    * Gibt genau dann true zurück, wenn sich der "Mittelpunkt" des Turtle-Dreiecks auf dem Rand eines anderen graphischen Objekts mit
    * der angegebenen Farbe befindet.
    **/
   public final boolean collidesWithBorderColor(int borderColor);

   /**
    * Gibt genau dann true zurück, wenn sich der "Mittelpunkt" des Turtle-Dreiecks auf dem Rand eines anderen graphischen Objekts mit
    * der angegebenen Farbe befindet.
    **/
   public final boolean collidesWithBorderColor(String borderColor);

   /**
    * Gibt die Länge des letzten gezeichneten Streckenzugs zurück.
    **/
   public final double getLastSegmentLength();

   /**
    * Gibt die x-Koordinate der aktuellen Turtleposition zurück.
    **/
   public final double getX();

   /**
    * Gibt die y-Koordinate der aktuellen Turtleposition zurück.
    **/
   public final double getY();

   /**
    * Bewirkt, dass die Turtle zum Punkt (x, y) geht.
    **/
   public final void moveTo(double x, double y);

   /**
    * Gibt den Blickwinkel der Turtle in Grad zurück.
    **/
   public final double getTurtleAngle();

   /**
    * Erstellt eine Kopie der Turtle.
    **/
   public final Turtle copy();

   /**
    * Wandelt das Objekt in eine Zeichenkette um und liefert diese zurück.
    **/
   public String toString();

   /**
    * Gibt genau dann true zurück, wenn die Figur mit der anderen Figur überlappt.
    **/
   public final boolean collidesWith(Shape otherShape);

}

/**
 * Klasse mit einer statischen Methode zum Encodieren von URLs.
 **/
public class URLEncoder {
   /**
    * Encodiert eine URL gemäß RFC3986.
    **/
   public static String encode(String url);

}

public class Vector<E> {
   /**
    * Instanziert (d.h. erzeugt) eine neue, leere Liste.
    **/
   public Vector();

}

/**
 * Ein zweidimensionaler Vektor mit double-Koordinaten.
 **/
public class Vector2 {
   /**
    * X-Komponente des Vektors
    **/
   public double x;
   /**
    * Y-Komponente des Vektors
    **/
   public double y;
   /**
    * Erstellt einen neuen Vektor mit den Koordinaten (x, y).
    **/
   public Vector2(double x, double y);

   /**
    * Wandelt den Vektor in einen String der Form (x, y) um.
    **/
   public static Vector2 fromPolarCoordinates();

   /**
    * Gibt den Winkel zur positiven x-Achse in Grad zurück.
    **/
   public final double getAngleDeg();

   /**
    * Gibt den Winkel zur positiven x-Achse im Bogenmaß (rad) zurück.
    **/
   public final double getAngleRad();

   /**
    * Gibt die Länge des Vektors zurück.
    **/
   public final double getLength();

   /**
    * Gibt einen NEUEN Vektor zurück, der parallel zu diesem ist aber die Länge 1 besitzt.
    **/
   public final Vector2 getUnitVector();

   /**
    * Streckt/staucht das Vector2-Objekt auf die angegebene Länge und gibt es zurück (für Method-Chaining!). Das Vector2-Objekt wird
    * dabei verändert!
    **/
   public final Vector2 setLength(double newLength);

   /**
    * Gibt ein NEUES Vector2-Objekt zurück, das parallel zu diesem ist aber um den angegebenen Faktor gestreckt ist.
    **/
   public final Vector2 scaledBy(double factor);

   /**
    * Streckt das Vector2-Objekt um den angegebenen Faktor und gibt es zurück (für Method-Chaining!). Diese Methode VERÄNDERT dieses
    * Objekt!
    **/
   public final Vector2 scale(double factor);

   /**
    * Gibt ein NEUES Vector2-Objekt zurück, das um den angegebenen Winkel (in Grad) gedreht ist. Positive Winkel bedeuten eine Drehung
    * ENTGEGEN dem Uhrzeigersinn.
    **/
   public final Vector2 rotatedBy(double angleDeg);

   /**
    * Rotiert das Vector2-Objekt um den angegebenen Winkel (in Grad) und gibt es zurück (für Method-Chaining!). Positive Winkel
    * bedeuten eine Drehung ENTGEGEN dem Uhrzeigersinn.
    **/
   public final Vector2 rotate(double angleDeg);

   /**
    * Gibt ein NEUES Vector2-Objekt zurück, das aus Addition der beiden Vektoren entsteht.
    **/
   public final Vector2 plus(Vector2 otherVector);

   /**
    * Gibt ein NEUES Vector2-Objekt zurück, das aus Subtraktion der beiden Vektoren entsteht.
    **/
   public final Vector2 minus(Vector2 otherVector);

   /**
    * Addiert den übergebenen Vektor zu diesem und gibt diesen zurück (für Method-Chaining!). Diese Methode VERÄNDERT dieses Objekt!
    **/
   public final Vector2 add(Vector2 otherVector);

   /**
    * Subtrahiert den übergebenen Vektor von diesem und gibt diesen zurück (für Method-Chaining!). Diese Methode VERÄNDERT dieses
    * Objekt!
    **/
   public final Vector2 sub(Vector2 otherVector);

   /**
    * Gibt das Skalarprodukt der beiden Vektoren zurück.
    **/
   public final double scalarProduct(Vector2 otherVector);

   /**
    * Berechnet die Länge der Differenz der beiden Vektoren.
    **/
   public final double distanceTo(Vector2 otherVector);

   /**
    * Berechnet den Abstand der beiden Punkte (x1, y1) und (x2, y2).
    **/
   public static final double distance(double x1, double y1, double x2, double y2);

   /**
    * Gibt genau dann true zurück, wenn das Objekt und das übergebene Objekt 'gleich' sind.
    **/
   public boolean equals(Vector2 otherVector);

   /**
    * Wandelt den Vektor in einen String der Form (x, y) um.
    **/
   public String toString();

}

/**
 * Ein zweidimensionaler Vektor mit double-Koordinaten.
 **/
public class Vector3 {
   /**
    * X-Komponente des Vektors
    **/
   public double x;
   /**
    * Y-Komponente des Vektors
    **/
   public double y;
   /**
    * Y-Komponente des Vektors
    **/
   public double z;
   /**
    * Erstellt einen neuen Vektor mit den Koordinaten (x, y).
    **/
   public Vector3(double x, double y, double z);

   /**
    * Erstellt einen neuen Vektor mit den Koordinaten (x, y).
    **/
   public Vector3(Vector2 xy, double z);

   /**
    * Erstellt einen neuen Vektor mit den Koordinaten (x, y).
    **/
   public Vector3(double x, Vector2 yz);

   /**
    * Gibt die Länge des Vektors zurück.
    **/
   public final double getLength();

   /**
    * Gibt einen NEUEN Vektor zurück, der parallel zu diesem ist aber die Länge 1 besitzt.
    **/
   public final Vector3 getUnitVector();

   public final Vector2 xy();

   public final Vector2 xz();

   public final Vector2 yz();

   /**
    * Streckt/staucht das Vector3-Objekt auf die angegebene Länge und gibt es zurück (für Method-Chaining!). Das Vector3-Objekt wird
    * dabei verändert!
    **/
   public final Vector3 setLength(double newLength);

   /**
    * Gibt ein NEUES Vector3-Objekt zurück, das parallel zu diesem ist aber um den angegebenen Faktor gestreckt ist.
    **/
   public final Vector3 scaledBy(double factor);

   /**
    * Streckt das Vector3-Objekt um den angegebenen Faktor und gibt es zurück (für Method-Chaining!). Diese Methode VERÄNDERT dieses
    * Objekt!
    **/
   public final Vector3 scale(double factor);

   /**
    * Gibt ein NEUES Vector3-Objekt zurück, das aus Addition der beiden Vektoren entsteht.
    **/
   public final Vector3 plus(Vector3 otherVector);

   /**
    * Gibt ein NEUES Vector3-Objekt zurück, das aus Subtraktion der beiden Vektoren entsteht.
    **/
   public final Vector3 minus(Vector3 otherVector);

   /**
    * Addiert den übergebenen Vektor zu diesem und gibt diesen zurück (für Method-Chaining!). Diese Methode VERÄNDERT dieses Objekt!
    **/
   public final Vector3 add(Vector3 otherVector);

   /**
    * Subtrahiert den übergebenen Vektor von diesem und gibt diesen zurück (für Method-Chaining!). Diese Methode VERÄNDERT dieses
    * Objekt!
    **/
   public final Vector3 sub(Vector3 otherVector);

   /**
    * Gibt das Skalarprodukt der beiden Vektoren zurück.
    **/
   public final double scalarProduct(Vector3 otherVector);

   /**
    * Berechnet die Länge der Differenz der beiden Vektoren.
    **/
   public final double distanceTo(Vector3 otherVector);

   /**
    * Berechnet den Abstand der beiden Punkte (x1, y1) und (x2, y2).
    **/
   public static final double distance(double x1, double y1, double z1, double x2, double y2, double z2);

   /**
    * Multipliziert diesen Vektor (von links) mit der gegebenen Matrix (mit ergänzter 1 in der 4. Dimension) und teilt durch den
    * perspektivischen Faktor.
    **/
   public final Vector3 applyMatrix4(Matrix4 m);

   /**
    * Gibt genau dann true zurück, wenn das Objekt und das übergebene Objekt 'gleich' sind.
    **/
   public boolean equals(Vector3 otherVector);

   /**
    * Wandelt den Vektor in einen String der Form (x, y) um.
    **/
   public String toString();

}

/**
 * Ein Objekt der Klasse WebSocket kann Daten über das Internet senden und empfangen. Um die Klasse benutzen zu können, musst Du
 * eine eigene Klasse schreiben, die die Klasse WebSocket erweitert und die Methoden onConnect, onMessage, onOtherClientConnected
 * und onOtherClientDisconnected überschreibt.
 **/
public class WebSocket {
   /**
    * Instanziert ein neues WebSocket-Objekt.
    **/
   public WebSocket();

   /**
    * Startet die Verbindung mit dem Server. Den SessionCode kannst Du frei wählen. Mit allen anderen Clients, die eine Verbindung mit
    * demselben SessionCode aufbauen, kannst Du anschließend Daten austauschen. Auch der Nickname ist frei wählbar. Er ist für alle
    * anderen Clients sichtbar.
    **/
   public void open(String sessionCode, String nickname);

   /**
    * Sendet Daten (message) an alle anderen Clients. Den messageType kannst Du frei wählen. Die empfangenden Clients bekommen ihn
    * zusammen mit den Daten übermittelt. Tipp: Du kannst auch Objekte senden, musst sie dazu aber vorher serialisieren, d.h. mithilfe
    * der Methode toJson in eine Zeichenkette verwandeln.
    **/
   public void sendToAll(String message, String messageType);

   /**
    * Sucht die übergebene Anzahl von "kontaktbereiten" Clients, d.h. solchen Clients, die exakt dieselbe Suchanfrage abgegeben haben.
    * Findet der Server die Clients, so ruft er bei allen beteiligten Clients onClientsFound auf.
    **/
   public void findClients(int count);

   /**
    * Sucht die Clients mit den angegebenen Nicknames. Haben sie eine entsprechende Suchanfrage (d.h. dieselben Nicknames) abgegeben,
    * so so ruft der Server bei allen beteiligten Clients onClientsFound auf.
    **/
   public void findClients(String[] nicknames);

   /**
    * Sucht den Client mit dem angegebenen Nickname. Hat er eine entsprechende Suchanfrage (d.h. mit dem Nickname DIESES clients)
    * abgegeben, so so ruft der Server bei beiden Clients onClientsFound auf.
    **/
   public void findClient(String nicknames);

   /**
    * Beendet die Verbindung. Bei allen anderen Clients, die sich mit derselben sessionId verbunden haben, wird daraufhin die Methode
    * onOtherClientDisconnected aufgerufen.
    **/
   public void close();

   /**
    * Gibt alle bisher bei der selben Session angemeldeten Clients zurück.
    **/
   public WebSocketClient getOtherClients();

   /**
    * Wird aufgerufen, sobald die Verbindung mit dem Server zustandegekommen ist.
    **/
   public void onOpen();

   /**
    * Wird aufgerufen, nachdem die Verbindung geschlossen wurde.
    **/
   public void onClose();

   /**
    * Wird immer dann aufgerufen, wenn eine Nachricht eines anderen Clients empfangen wurde.
    **/
   public void onMessage(WebSocketClient sender, String message, String messageType);

   /**
    * Wird immer dann aufgerufen, wenn ein anderer Client unter Nutzung desselben sessionCodes die Verbindung mit dem Server öffnet.
    **/
   public void onOtherClientConnected(WebSocketClient otherClient);

   /**
    * Wird immer dann aufgerufen, wenn ein anderer Client unter Nutzung desselben sessionCodes die Verbindung mit dem Server beendet
    * hat.
    **/
   public void onOtherClientDisconnected(WebSocketClient otherClient);

   /**
    * Wird aufgerufen, wenn die durch die Methoden findClient bzw. findClients zuvor gesuchten Clients gefunden wurden.
    **/
   public void onClientsFound(WebSocketClient[] otherClients, int ownNumber);

}

/**
 * Ein Objekt der Klasse WebSocketClient repräsentiert einen anderen Rechner, mit dem dieser Rechner über den WebSocket in Kontakt
 * steht.
 **/
public class WebSocketClient {
   /**
    * Sendet Daten (message) an diesen Client. Den messageType kannst Du frei wählen. Die client bekommt ihn zusammen mit den Daten
    * übermittelt. Tipp: Du kannst auch Objekte senden, musst sie dazu aber vorher serialisieren, d.h. mithilfe der Methode toJson in
    * eine Zeichenkette verwandeln.
    **/
   public void send(String message, String messageType);

   /**
    * Mit dieser Methode kannst Du beliebige Objektreferenzen in diesem WebSocketClient-Objekt speichern. Den Schlüssel kannst Du
    * dabei frei wählen und später nutzen, um den Wert durch die Methode getUserData wieder zu holen.
    **/
   public void setUserData(String key, Object value);

   /**
    * Mit dieser Methode kannst Du eine Objektreferenz erhalten, die Du zuvor mit der Methode setUserData gespeichert hast.
    * Bemerkung1: Diese Methode entfernt die Objekreferenz nicht aus dem WebSocketClient-Objekt. Bemerkung2: Damit Du alle Methoden
    * des erhaltenen Objekts aufrufen kannst, musst Du dem Computer mitteilen, von welcher Klasse es ist ('casten'). Das geht für die
    * Klasse MeineNutzerDaten bspw. so: MeineNutzerDaten mnd = (MeineNutzerDaten)client.getUserData('schlüssel');
    **/
   public Object getUserData(String key);

   public String getFirstName();

   public String getLastName();

   public String getNickname();

   public String getUserName();

   /**
    * Gehört ein Client zu einer mit findClient bzw. findClients gefundenen Gruppe, so erhältst Du mit dieser Methode die 'Rangfolge'
    * dieses Clients in dieser Gruppe. Allen Clients wird dieselbe Rangfolgeordnung vom Server mitgeteilt. So lässt sich bspw. einfach
    * festlegen, welcher Client eine besondere Rolle (Server) in der Gruppe erhalten soll (z.B. Client mit Nummer 1). Bemerkung: Die
    * Nummer ist eine Zahl zwischen 1 und der Anzahl der Clients in der Gruppe.
    **/
   public String getNumber();

   /**
    * Diese Methode ist veraltet. Benutze stattdessen getNumber.
    **/
   public String getIndex();

}

public class World {
   public World();

   public World(int width, int height);

   /**
    * Setzt die Hintergrundfarbe. Die Farbe wird als Color-Objekt erwartet.
    **/
   public void setBackgroundColor(Color colorAsObject);

   /**
    * Setzt die Hintergrundfarbe. Die Farbe wird als integer-Zahl erwartet. Am besten schreibt man sie als Hexadezimalzahl, also z.B.
    * setBackgroundColor(0xff8080).
    **/
   public void setBackgroundColor(int colorAsRGBInt);

   /**
    * Setzt die Hintergrundfarbe. Die Farbe ist entweder eine vordefinierte Farbe ("schwarz", "rot", ...) oder eine css-Farbe der Art
    * "#ffa7b3" (ohne alpha), "#ffa7b380" (mit alpha), "rgb(172, 22, 18)" oder "rgba(123, 22,18, 0.3)
    **/
   public void setBackgroundColor(String colorAsString);

   /**
    * Verschiebt alle Objekte der Welt um dx nach rechts und dy nach unten.
    * Tipp: Falls Objekte NICHT mitverschoben werden sollen, rufe die Methode setStatic(true) auf.
    **/
   public void move(double dx, double dy);

   /**
    * Rotiert die Welt um den angegebenen Winkel (in Grad!) im Urzeigersinn. Drehpunkt ist der Punkt (centerX, centerY).
    * Tipp: Falls Objekte NICHT mitgedreht werden sollen, rufe die Methode setStatic(true) auf.
    **/
   public void rotate(double angleInDeg, double centerX, double centerY);

   /**
    * Streckt die Welt um den angegebenen Faktor. Zentrum der Streckung ist (CenterX, centerY). Drehpunkt ist der Punkt (centerX,
    * centerY).
    * Tipp: Falls Objekte NICHT mitgedreht werden sollen, rufe die Methode setStatic(true) auf.
    **/
   public void scale(double factor, double centerX, double centerY);

   /**
    * Setzt das Koordinatensystem der Welt so, dass (left, top) die linke obere Ecke des sichtbaren Bereiches ist, width seine Breite
    * und height seine Höhe.
    **/
   public void setCoordinateSystem(double left, double top, double width, double height);

   /**
    * Ändert die Form des Mauscursors im gesamten Grafikbereich. Mögliche Werte: siehe
    * https://developer.mozilla.org/en-US/docs/Web/CSS/cursor.
    **/
   public void setCursor(String cursor);

   /**
    * Löscht alle Grafikobjekte in der Welt, indem es ihre destroy()-Methode aufruft.
    **/
   public static void clear();

   /**
    * Gibt die Breite des sichtbaren Bereichs der Welt zurück.
    **/
   public double getWidth();

   /**
    * Gibt die Höhe des sichtbaren Bereichs der Welt zurück.
    **/
   public double getHeight();

   /**
    * Gibt die Y-Koordinate der linken oberen Ecke des sichtbaren Bereichs der Welt zurück.
    **/
   public double getTop();

   /**
    * Gibt die X-Koordinate der linken oberen Ecke des sichtbaren Bereichs der Welt zurück.
    **/
   public double getLeft();

   /**
    * Gibt die Gruppe zurück, zu der aktuell alle neuen Objekte automatisch hinzugefügt werden. Falls gerade keine defaultGroup
    * festgelegt ist, wird null zurückgegeben.
    **/
   public Group<T> getDefaultGroup();

   /**
    * Legt die Gruppe fest, zu der aktuell alle neuen Objekte automatisch hinzugefügt werden. Falls keine defaultGroup gewünscht ist,
    * rufen Sie setDefaultGroup(null) auf.
    **/
   public void setDefaultGroup(Group<T> defaultGroup);

   /**
    * Verschiebt die Welt so, dass das übergebene graphische Objekt (shape) sichtbar wird. Verschoben wird nur, wenn das Objekt
    * weniger als frameWidth vom Rand entfernt ist und die Welt nicht über die gegebenen Koordinaten xMin, xMax, yMin und yMax
    * hinausragt.
    **/
   public void follow(Shape shape, double margin, double xMin, double xMax, double yMin, double yMax);

   /**
    * Fügt einen neuen MouseListener hinzu, dessen Methoden bei Mausereignissen aufgerufen werden.
    **/
   public void addMouseListener(MouseListener mouseListener);

   /**
    * Gibt das aktuelle World-Objekt zurück.
    **/
   public static World getWorld();

}

public class World3d {
   public World3d();

   /**
    * Setzt die Hintergrundfarbe. Die Farbe wird als integer-Zahl erwartet. Am besten schreibt man sie als Hexadezimalzahl, also z.B.
    * setBackgroundColor(0xff8080).
    **/
   public void setBackgroundColor(int colorAsRGBInt);

   /**
    * Setzt die Hintergrundfarbe. Die Farbe ist entweder eine vordefinierte Farbe ("schwarz", "rot", ...) oder eine css-Farbe der Art
    * "#ffa7b3" (ohne alpha), "#ffa7b380" (mit alpha), "rgb(172, 22, 18)" oder "rgba(123, 22,18, 0.3)
    **/
   public void setBackgroundColor(String colorAsString);

   /**
    * Setzt die Hintergrundfarbe. Die Farbe ist entweder eine vordefinierte Farbe ("schwarz", "rot", ...) oder eine css-Farbe der Art
    * "#ffa7b3" (ohne alpha), "#ffa7b380" (mit alpha), "rgb(172, 22, 18)" oder "rgba(123, 22,18, 0.3)
    **/
   public void setBackgroundColor(Color colorObject);

   /**
    * Ändert die Form des Mauscursors im gesamten Grafikbereich. Mögliche Werte: siehe
    * https://developer.mozilla.org/en-US/docs/Web/CSS/cursor.
    **/
   public void setCursor(String cursor);

   /**
    * Löscht alle Grafikobjekte in der Welt, indem es ihre destroy()-Methode aufruft.
    **/
   public void clear();

   /**
    * Fügt einen neuen MouseListener hinzu, dessen Methoden bei Mausereignissen aufgerufen werden.
    **/
   public void addMouseListener(MouseListener mouseListener);

   /**
    * Gibt ein Array mit allen Light3d-Objekten zurück.
    **/
   public Light3d[] getLights();

   /**
    * Entfernt alle Light3d-Objekte.
    **/
   public void removeAllLights();

   /**
    * Entfernt das Light3d-Objekt. Die Lichtquelle ist dann nicht mehr aktiv.
    **/
   public void removeLight(Light3d light);

   /**
    * Fügt der Szene die gegebene Lichtquelle hinzu.
    **/
   public void addLight(Light3d light);

   public void setCamera(Camera3d camera);

   public Camera3d getCamera();

   public void removeCoordinateAxes();

   public void removeOrbitControls();

   /**
    * Gibt das aktuelle World3d-Objekt zurück.
    **/
   public static World3d getWorld3d();

}

